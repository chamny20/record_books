# 6️⃣ Ch6

### 6.1 함수 추출하기

코드를 언제 독립된 함수로 묶어야 할 지에 관한 의견은 수없이 많다.

→ 길이를 기준으로 하거나, 재사용성을 기준으로 하는 등등

중요한 점은 \*\*`‘목적과 구현을 분리’하는 방식`\*\*이 가장 합리적인 기준

⇒ 나중에 코드를 다시 읽을 때 함수의 목적이 눈에 확 들어오고 본문 코드에 대해서 확실히 파악 가능

\*함수 호출이 많아져서 성능이 느려질까 걱정?

⇒ 거의 그럴 일이 없다. 함수가 짧으면 캐싱하기가 더 쉽기 때문에 컴파일러가 최적화하는 데 유리할 때가 많다.

음..

‘최적화를 할 때는 다음 규칙을 따르기 바란다. 첫 번째, 하지 마라. 두 번째, 아직 하지 마라’

..

ㅋㅋ

* 절차
  * 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다. ‘어떻게’가 아닌 ‘무엇을’ 하는지가 드러나야 한다.
  * 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣는다.
  * 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다.
  * 변수를 다 처리했다면 컴파일한다.
  * 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다. (즉, 추출한 함수로 일을 위임한다.)
  * 테스트한다.
  * 다른 코드에 방금 추출한 것과 똑같거나 비슷한 코드가 없는지 살핀다. 있다면 방금 추출한 새 함수를 호출하도록 바꿀지 검토한다. (인라인 코드를 함수 호출로 바꾸기)

\[예시]

* 유효범위를 벗어나는 변수가 없을 때
* 지역 변수를 사용할 때
* 지역 변수의 값을 변경할 때

❓값을 반환할 변수가 여러 개라면?

> “개인적으로 함수가 값 하나만 반환하는 방식을 선호하기 때문에 각각을 반환하는 함수 여러 개로 만든다.” ”중첩 함수로 추출할 수 있더라고 최소한 원본 함수와 같은 수준의 문맥으로 먼저 추출해보자.”

### 6.2 함수 인라인하기

6.1에서의 함수 추출하기와 반대 개념 (반대 리팩터링)

* 절차
  * 다형 메서드인지 확인한다.
  * 인라인할 함수를 호출하는 곳을 모두 찾는다.
  * 각 호출문을 함수 본문으로 교체한다.
  * 하나씩 교체할 때마다 테스트한다.
  * 함수 정의(원래 함수)를 삭제한다.

⇒ 핵심은!? 항상 단계를 잘게 나눠서 처리하는 데 있다.

나는 평소에 함수 인라인하기 방식을 많이 쓰는 것 같다..

### 6.3 변수 추출하기

반대 리팩터링: 변수 인라인하기

주로 표현식이 복잡한 경우에 사용한다. 표현식에 이름을 붙임으로써 문맥을 알아볼 수 있는 의미로 추출하는 것이 좋다.

* 절차
  * 추출하려는 표현식에 부작용은 없는지 확인한다.
  * 불변 변수를 하나 선언하고 이름을 붙일 표현식의 복제본을 대입한다.
  * 원본 표현식을 새로 만든 변수로 교체한다.
  * 테스트한다.
  * 표현식을 여러 곳에서 사용한다면 각각을 새로 만든 변수로 교체한다. 하나 교체할 때마다 테스트한다.

예시) 클래스 예제를 보면 확연한 장점이 보인다. 객체는 특정 로직과 데이터를 외부와 공유하려 할 때 공유할 정보를 설명해주는 적당한 크기의 문맥이 되어준다.

### 6.4 변수 인라인하기

반대 리팩터링: 변수 추출하기

변수 자체가 가끔은 주변 코드를 리팩터링하는 데 방해가 될 수 있기 때문에, 그러한 경우에 그 변수를 인라인하는 것이 좋다.

* 절차
  * 대입문의 우변(표현식)에서 부작용이 생기지는 않는지 확인한다.
  * 변수가 불변으로 선언되지 않았다면 불변으로 만든 후 테스트한다.
  * 이 변수를 가장 처음 사용하는 코드를 찾아서 대입문 우변의 코드로 바꾼다.
  * 테스트한다.
  * 변수를 사용하는 부분을 모두 교체할 때까지 이 과정을 반복한다.
  * 변수 선언문과 대입문을 지운다.
  * 테스트한다.

### 6.5 함수 선언 바꾸기

가장 중요한 요소는.. 함수의 이름!

> 좋은 이름을 떠올리는 데 효과적인 방법이 하나 있다. 바로 주석을 이용해 함수의 목적을 설명해보는 것이다. 그러다 보면 주석이 멋진 이름으로 바뀌어 되돌아올 때가 있다.

**\[간단한 절차]**

1. 매개변수를 제거하려거든 먼저 함수 본문에서 제거 대상 매개변수를 참조하는 곳은 없는지 확인한다.
2. 메서드 선언을 원하는 형태로 바꾼다.
3. 기존 메서드 선언을 참조하는 부분을 모두 찾아서 바뀐 형태로 수정한다.
4. 테스트한다.

**\[마이그레이션 절차]**

1. 이어지는 추출 단계를 수월하게 만들어야 한다면 함수의 본문을 적절히 리팩터링한다.
2. 함수 본문을 새로운 함수로 추출한다.
3. 추출한 함수에 매개변수를 추가해야 한다면 ‘간단한 절차’를 따라 추가한다.
4. 테스트한다.
5. 기존 함수를 인라인한다.
6. 이름을 임시로 붙여뒀다면 함수 선언 바꾸기를 한 번 더 적용해서 원래 이름으로 되돌린다.
7. 테스트한다.

\*호출문을 변경하기 전에 어서션을 추가하여 호출하는 곳에서 새로 추가한 매개변수를 실제로 사용하는지 확인 가능

`assert(isPrioirty === true || isPriority === false);`

### 6.6 변수 캡슐화하기

\[절차]

1. 변수로의 접근과 갱신을 전담하는 캡슐화 함수들을 만든다.
2. 정적 검사를 수행한다.
3. 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 바꾼다. 하나씩 바꿀 때마다 테스트한다.
4. 변수의 접근 범위를 제한한다.
5. 테스트한다.
6. 변수 값이 레코드라면 레코드 캡슐화하기를 적용할지 고려해본다.

defaultOwner(), setDefaultOwner() (세터함수) ⇒ 인상깊다!

*   게터가 데이터의 복제본을 반환하도록 수정하는 식으로 처리한다.

    ⇒ 원본에는 아무 영향을 주지 않기 때문에 장단점이 있음

    ⇒ 원본 데이터를 갱신하길 원할 수도 있기 때문

### 6.7 변수 이름 바꾸기

“명확한 프로그래밍의 핵심은 이름짓기”!!!

* 동적 타입 언어라면 이름 앞에 타입을 드러내는 문자를 붙이는 편이 대개 좋은 것 같다. (ex. aCustomer)
* 값이 영속되는 ‘필드’라면 네이밍 더 신경쓰기

\[절차]

1. 폭넓게 쓰이는 변수라면 변수 캡슐화하기를 고려한다.
2. 이름을 바꿀 변수를 참조하는 곳을 모두 찾아서, 하나씩 변경한다.
3. 테스트한다.

* 임시 변수나 인수처럼 유효범위가 함수 하나로 국한된 변수일 때 ‘변수 이름 바꾸기’
* 상수 이름 바꾸기

### 6.8 매개변수 객체 만들기

\[절차]

1. 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다.
2. 테스트한다.
3. 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가한다.
4. 테스트한다.
5. 함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다. 하나씩 수정할 때마다 테스트한다.
6. 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다.
7. 다 바꿨다면 기존 매개변수를 제거하고 테스트한다.

예시) 온도 측정값

### 6.9 여러 함수를 클래스로 묶기

\[절차]

1. 함수들이 공유하는 공통 데이터 레코드를 캡슐화한다.
2. 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다.
3. 데이터를 조작하는 로직들은 함수로 추출해서 새 클래스로 옮긴다.

* 단일 접근 원칙 (Uniform Access Principle)
* 프로그램(의 다른 부분)에서 데이터를 갱신할 가능성이 꽤 있을 때는 클래스로 묶어두면 큰 도움이 된다.

### 6.10 여러 함수를 변환 함수로 묶기

도출 로직이 반복됨 → 한곳에 모아두기 → 검색과 갱신을 일관된 장소에서 처리할 수 있고 로직 중복도 막을 수 있다.

⇒ **`“변환 함수”`** 사용하기

* 변환 함수
  * 원본 데이터를 입력받아서 필요한 정보를 모두 도출한 뒤, 각각을 출력 데이터의 필드에 넣어 반환한다.
  * 이후 도출 과정을 검토할 일이 생겼을 때 변환 함수만 살펴보면 된다.

\[절차]

1. 변환할 레코드를 입력받아서 값을 그대로 반환하는 변환 함수를 만든다.
2. 묶을 함수 중 함수 하나를 골라서 본문 코드를 변환 함수로 옮기고, 처리 결과를 레코드에 새 필드로 기록한다. 그런 다음 클라이언트 코드가 이 필드를 사용하도록 수정한다.
3. 테스트한다.
4. 나머지 관련 함수도 위 과정에 따라 처리한다.

* 깊은 복사 → `lodash` 라이브러리에서 제공하는 cloneDeep()로 처리

### 6.11 단계 쪼개기

서로 다른 두 대상을 한꺼번에 다루는 코드가 나타나면?

→ 각각을 별개 모듈로 나누는 방법을 모색 (하나에만 집중하기 위해서)

가장 간편한 방법?

* 동작을 연이은 두 단계로 쪼개는 것

ex. 컴파일러

⇒ 기본적으로 어떤 텍스트를 입력받아서 실행 가능한 형태로 변환

⇒ 즉, 텍스트를 토큰화하고, 토큰을 파싱해서 구문 트리를 만들고, 구문 트리를 변환하는 다양한 단계를 거친 다음, 마지막으로 목적 코드를 생성하는 식이다.

\[절차]

1. 두 번째 단계에 해당하는 코드를 독립 함수로 추출한다.
2. 테스트한다.
3. 중간 데이터 구조를 만들어서 앞에서 추출한 함수의 인수로 추가한다.
4. 테스트한다.
5. 추출한 두 번째 단계 함수의 매개변수를 하나씩 검토한다. 그중 첫 번째 단계에서 사용되는 것은 중간 데이터 구조로 옮긴다. 하나씩 옮길 때마다 테스트한다.
6. 첫 번째 단계 코드를 함수로 추출하면서 중간 데이터 구조를 반환하도록 만든다.
