# Ch2

### 2.1 리팩터링 정의

> **리팩터링 : `[명사]` 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법**

> **리팩터링 : `[동사]` 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.**

_**“누군가 “리팩터링하다가 코드가 깨져서 며칠이나 고생했다”라고 한다면, 십중팔구 리팩터링한 것이 아니다.”**_

오…

여기서 저자는 다음과 같이 정의한다.

* 재구성 : 코드베이스를 정리하거나 구조를 바꾸는 모든 작업
* 리팩터링 : 재구성 중 특수한 하나의 형태

_**“리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아있어야 한다.”**_

오잉…왜?

리팩터링은 성능 최적화와 비슷하다.

* 리팩터링의 목적 : 코드를 이해하고 수정하기 쉽게 만드는 것, 성능에 관계없이
* 성능 최적화 : 오로지 속도 개선에만 신경 쓴다.

### 2.2 두 개의 모자

저자는 소프트웨어를 개발할 때 목적에 따라 작업을 명확히 구분한다고 한다. 기능을 추가할 때는 ‘기능 추가’모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. 반면 리팩터링할 때는 ‘리팩터링’ 모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다.

각 작업 마다의 미묘한 작업 방식의 차이를 분명하게 인식해야 한다고 한다.

흠..

### 2.3 리팩터링하는 이유

* 리팩터링하면 소프트웨어 설계가 좋아진다.
  * 코드가 길수록 실수 없이 수정하기 어려워진다. 이해해야 할 코드량도 늘어난다.
* 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
* 리팩터링하면 버그를 쉽게 찾을 수 있다.
* 리팩터링하면 프로그래밍 속도를 높일 수 있다.
  * 시간이 지날 수록 ‘좋은 설계’일수록 기능의 누적 질이 정비례
  * 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.
  *   지구력 가설 - 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.

      ⇒ 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.

### 2.4 언제 리팩터링해야 할까?

`**“나는 프로그래밍할 때 거의 한 시간 간격으로 리팩터링한다.”**`

* **3의 법칙**
  * 처음에는 그냥 한다.
  * 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.
  * 비슷한 일을 세 번째 하게 되면 리팩터링한다.
* **준비를 위한 리팩터링**: 기능을 쉽게 추가하게 만들기
* **이해를 위한 리팩터링**: 코드를 이해하기 쉽게 만들기
* **쓰레기 줍기 리팩터링**
  * 간단히 수정할 수 있는 건 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다.

**⇒ 준비, 이해를 위한 리팩터링, 쓰레기 줍기 리팩터링은 모두 “기회가 될 때만” 진행한다.**

* **오래 걸리는 리팩터링**
  * 라이브러리를 새 것으로 교체하는 작업일 수도 있고,
  * 일부 코드를 다른 팀과 공유하기 위해 컴포넌트로 빼내는 작업일 수도 있다.
  * 작업하면서 쌓여온 골치 아픈 의존성을 정리하는 작업일 수도 있다.
* 코드 리뷰에 리팩터링 활용하기
  *   **페어 프로그래밍** - 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링하는 것

      ⇒ 프로그래밍 과정 안에 지속적인 코드 리뷰가 녹아 있는!
* 리팩터링하지 말아야 할 때
  * 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.

### 2.5 리팩터링 시 고려할 문제

* 새 기능 개발 속도 저하
  * 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

**`“사람들이 빠지기 쉬운 가장 위험한 오류는 리팩터링을 ‘클린 코드’나 ‘바람직한 엔지니어링 습관’처럼 도덕적인 이유로 정당화하는 것이다.”`**

⇒ 리팩터링은 **“개발 기간”을 단축하고자 하는 것**이다. 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다.

* 코드 소유권
  * 코드의 소유권을 ‘팀’에 두는 것이 좋다.
* 브랜치
  * 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다.
    * 그래서 많은 이들이 마스터를 개인 브랜치로 수시로 리베이스하거나 머지한다.
  * 마스터를 브랜치로 ‘머지’하는 작업은 “단방향”이다.
  * “통합”은 마스터를 개인 브랜치로 가져와서(pull해서) 작업한 결과를 다시 마스터에 올리는(push) “양방향” 처리를 뜻한다.
  * 기능별 브랜치의 통합 주기를 매우 짧게 관리해야 한다는 방식 ⇒ 지속적 통합(CI), 트렁크 기반 개발(Trunk-Based-Development;TBD)
    * CI에 따르면, 모든 팀원이 하루에 최소 한 번은 마스터와 통합 ⇒ 머지의 복잡도 낮출 수 있다.
    * 리팩터링과 궁합이 아주 좋음
* **테스팅**
  * 리팩터링하기 위해서는 대부분의 경우에 \*\*‘자가 테스트 코드’\*\*를 마련해야 한다.
  * 핵심은 테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있다는 데 있다. 테스트 주기가 짧다면 단 몇 줄만 비교하면 되며, 문제를 일으킨 부분이 그 몇 줄 안에 있기 때문에 버그를 훨씬 쉽게 찾을 수 있다.
* **레거시 코드**
  * 물려받은 레거시 코드는 대체로 복잡하고 테스트도 제대로 갖춰지지 않은 것이 많다.
  * 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다.
    * 테스트 보강이 필수
* **데이터베이스**
  * 데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다.

### 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

* 향후 변경에 유연하게 대처할 수 있는 **유연성 메커니즘**을 소프트웨어에 심어두는 것이 좋다.
*   **YAGNI == you aren’t going to need it**

    * 매개변수를 추가해야 할 시점이 오면 간단한 리팩터링 기법인 ‘함수 매개변수화하기’로 해결한다.
    * 예상되는 변경을 미리 반영하는 리팩터링을 미루면 나중에 얼마나 어려워질지를 가늠해보면 판단에 도움될 때가 많다.
    * 리팩터링을 미루면 훨씬 힘들어진다는 확신이 들 때만 유연성 메커니즘을 미리 추가한다.

    ⇒ 이런 식으로 설계하는 방식을 **‘간결한 설계’, ‘점진적 설계’, YAGNI**로 부름

### 2.7 리팩터링과 소프트웨어 개발 프로세스

* **`TDD(테스트 주도 개발) = 자가 테스트 코드 + 리팩터링`**
* 자가 테스트 코드, 지속적 통합, 리팩터링이라는 세 기법은 서로 강력한 상승효과를 발휘한다.

### 2.8 리팩터링과 성능

직관적인 설계 vs 성능 ⇒ 중요한 주제이다.

* 빠른 소프트웨어를 작성하는 방법 세 가지
  * 시간 예산 분배 방식
    * 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 자원 예산을 할당한다.
    * 엄격한 시간 엄수를 강조한다.
  * 끊임없이 관심을 기울이는 것
  * 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는 데 집중한다. 그러다 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝한다.
* 프로그램을 잘 리팩터링해두면 최적화에 두 가지 면에서 도움이 된다.
  * 성능 튜닝에 투입할 시간을 벌 수 있다.
  * 리팩터링이 잘 되어 있는 프로그램은 성능을 더 세밀하게 분석할 수 있다.

### 2.9 리팩터링의 유래

### 2.10 리팩터링 자동화

* 자동 리팩터링을 제대로 구현하려면 코드를 텍스트 상태가 아닌, 구문 트리로 해석해서 다뤄야 한다.
