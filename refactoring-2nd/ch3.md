# 3️⃣ Ch3

리팩터링할 ‘시점’을 설명하는 데 ‘냄새’란 표현을 사용했다고 한다..

인스턴스 변수는 몇 개가 적당한지, 메서드가 몇 줄을 넘어가면 안 좋은지 등은 각자 경험을 통해 감을 키워야 한다.

### 3.1 기이한 이름

* 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.
* 우리가 가장 많이 사용하는 리팩터링도!
  * 함수 선언 바꾸기 (함수 이름을 바꿀 때도 사용)
  * 변수 이름 바꾸기
  * 필드 이름 바꾸기

**`“마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.”`**

### 3.2 중복 코드

**코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다. 그중 하나를 변경할 때는 다른 비슷한 코드들도 모두 살펴보고 적절히 수정해야 한다.**

ex. 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우

* 함수 추출하기 - 양쪽 모두 추출된 메서드를 호출하게 바꾸면 된다.
* 문장 슬라이드하기 - 비슷한 부분을 한곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴보기
* 메서드 올리기 - 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있다면, 각자 따로 호출되지 않도록 하기

### 3.3 긴 함수

우리는 주석을 달아야 할 만한 부분은 무조건 함수로 만든다. 그 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고, 함수 이름은 동작 방식이 아닌 ‘의도’가 드러나게 짓는다.

**“단, 함수의 이름에 코드의 목적을 드러내야 한다. 여기서 핵심은 함수의 길이가 아닌, 함수의 목적(의도)과 구현 코드의 괴리가 얼마나 큰가다. 즉, ‘무엇을 하는지’를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다.”**

* **`함수 추출하기`** - 함수를 짧게 만드는 작업의 99%를 차지
  * 함수 본문에서 따로 묶어 빼내면 좋은 코드 덩어리를 찾아 새로운 함수로 만드는 것
* **`임시 변수를 질의 함수로 바꾸기`** ⇒ 임시 변수의 수를 줄일 수 있다.
* **`매개변수 객체 만들기, 객체 통째로 넘기기`** ⇒ 매개변수의 수를 줄일 수 있다.

❓위 방법을 적용해도 많다면?

**⇒ `‘함수를 명령으로 바꾸기’`를 고려해보자.**

* 조건문
  * `조건문 분해하기`
  * 거대한 switch문을 구성하는 case마다 `‘함수 추출하기’`를 적용해 각 case의 본문을 함수 호출문 하나로 바꾼다.
  * 같은 조건을 기준으로 나뉘는 switch문이 여러 개라면 `조건부 로직을 다형성으로 바꾸기`를 적용한다.
* 반복문
  * 그 안의 코드와 함께 추출해서 독립된 함수로 만든다.
  * `반복문 쪼개기`

### 3.4 긴 매개변수 목록

* 종종 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있는 경우
  * `매개변수를 질의 함수로 바꾸기`로 제거 가능
* 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드인 경우
  * `객체 통째로 넘기기`를 적용해 원본 데이터 구조를 그대로 전달
* 함께 전달되는 매개변수들은 `매개변수 객체 만들기`로 하나로 묶어버린다.
* 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 `플래그 인수 제거하기`로 없애준다.
* 클래스 → `여러 함수를 클래스로 묶기`를 이용해 공통 값들을 클래스의 필드로 정의

### 3.5 전역 데이터

전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.

→ 이를 방지하기 위해 사용하는 대표적인 리팩터링 : **`“변수 캡슐화하기”`**

⇒ 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용

→ 이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 됨

### 3.6 가변 데이터

* 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우
  * `변수 쪼개기` ⇒ 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다.
  * 갱신 로직을 위해 `문장 슬라이드하기, 함수 추출하기`를 이용해 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리한다.
* API를 만들 때
  * `질의 함수와 변경 함수 분리하기` ⇒ 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다.
    * `세터(setter) 제거하기`도 적용

값을 다른 곳에서 설정할 수 있는 가변 데이터가 풍기는 악취는 특히 고약하댄다…

⇒ `파생 변수를 질의 함수로 바꾸기`

* 유효범위 제한
  * `여러 함수를 클래스로 묶기`나 `여러 함수를 변환 함수로 묶기`를 활용해 변수를 갱신하는 코드들의 유효범위를 제한
  * ex. 구조체처럼, 내부 필드에 데이터를 담고 있는 변수라면 일반적으로 `참조를 값으로 바꾸기`를 적용 ⇒ 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫다.

### 3.7 뒤엉킨 변경

악취에는 두 가지가 있다고 한다…

* **뒤엉킨 변경**
* **산탄총 수술**

이게 도대체 무슨 소리야..

*   **뒤엉킨 변경**

    * 단일 책임 원칙(SRP)이 제대로 지켜지지 않을 때 발생
    * 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생

    ⇒ 분리를 잘 해야 함! 근데 개발 초기에는 맥락 사이의 경계를 명확히 나누기가 어려움 ㅠ

### 3.8 산탄총 수술

|           | 뒤엉킨 변경        | 산탄총 수술        |
| --------- | ------------- | ------------- |
| 원인        | 맥락을 잘 구분하지 못함 | 맥락을 잘 구분하지 못함 |
| 해법(원리)    | 맥락을 명확히 구분    | 맥락을 명확히 구분    |
| 발생 과정(현상) | 한 코드에 섞여 들어감  | 여러 코드에 흩뿌려짐   |
| 해법(실제 행동) | 맥락별로 분리       | 맥락별로 모음       |
