---
icon: '2'
---

# 2장 - 타입스크립트: 3,000미터 상공에서 내려다보기

### 2.1 컴파일러

프로그램 → 프로그래머가 작성한 다수의 텍스트 파일로 구성

이 텍스트 파일 → 컴파일러가 파싱하여 추상 문법 트리(AST) 자료구조로 변환

컴파일러는 다시 AST → bytecode로 하위 수준의 표현으로 변환

바이트코드가 만들어지면 → 런타임에서 평가하고 결과를 얻을 수 있다.

⇒ 즉, 프로그램을 실행한다는 것은 컴파일러가 소스 코드를 파싱해 AST로 만들고, 다시 AST를 바이트코드로 변환한 것을 런타임이 평가하도록 지시한다는 의미

1. 프로그램이 AST로 파싱된다.
2. AST가 바이트코드로 컴파일된다.
3. 런타임이 바이트코드를 평가한다.

\*타입스크립트의 특별한점: 컴파일러가 코드를 바이트코드 대신 자바스크립트 코드로 변환한다는 점

* 타입 검사기 (typechecker)
  * 코드의 타입 안전성을 검증하는 특별한 프로그램

**\[TS vs. JS]**

* TS
  1. 타입스크립트 소스 → 타입스크립트 AST
  2. 타입 검사기가 AST 확인
  3. 타입스크립트 AST → 자바스크립트 소스
* JS
  1. 자바스크립트 소스 → 자바스크립트 AST
  2. AST → 바이트코드
  3. 런타임이 바이트코드를 평가

⇒ 과정 1\~3은 TSC가 수행, 4\~6은 브라우저나 nodejs, 기타 자바스크립트 엔진같은 자바스크립트 런타임이 실행

### 2.2 타입 시스템

* type system: 타입 검사기가 프로그램에 타입을 할당하는 데 사용하는 규칙 집합
  * 어떤 타입을 사용하는지를 컴파일러에 명시적으로 알려주는 타입 시스템
  * 자동으로 타입을 추론하는 타입 시스템

```tsx
let a: number = 1;
let b: string = 'hello';
let c: boolean[] = [true, false];
```

```tsx
let a = 1;
let b = 'hello';
let c = [true, false];
```

**타입스크립트가 타입을 추론하도록 두는 것이 코드를 줄일 수 있는 방법이므로 보통 어노테이션은 생략한다.**

#### 2.2.1 타입스크립트 vs. 자바스크립트

| 타입 시스템 기능       | 자바스크립트   | 타입스크립트      |
| --------------- | -------- | ----------- |
| 타입 결정 방식        | 동적       | 정적          |
| 타입이 자동으로 변환되는가? | O        | X(대부분)      |
| 언제 타입을 확인하는가?   | 런타임      | 컴파일 타임      |
| 언제 에러를 검출하는가?   | 런타임(대부분) | 컴파일 타임(대부분) |

**타입은 어떻게 결정되는가?**

* 동적 타입 바인딩(dynamic type binding)
  * 자바스크립트가 프로그램을 실행해야만 특정 데이터의 타입을 알 수 있음을 의미
* 타입스크립트는 점진적으로 타입을 확인하는 언어
  * 타입스크립트는 컴파일 타임에 프로그램의 모든 타입을 알고 있을 때 최상의 결과를 보여줄 수 있지만, 프로그램을 컴파일하는 데 반드시 모든 타입을 알아야 하는 것은 아니다.
  * 점진적 타입 확인 → 타입을 지정하지 않은 기존 자바스크립트 코드를 타입스크립트로 마이그레이션할 때 특히 유용
  * 하지만..! 마이그레이션 상황이 아니라면 모든 코드의 타입을 컴파일 타임에 지정하는 것을 목표로 해야 한다.

**자동으로 타입이 변환되는가?**

* 자바스크립트는 약한 타입 언어
  * ex) 3 + \[1]을 어떻게 평가하냐 알아보자.
    * 자바스크립트는 3이 숫자고 \[1]은 배열임을 체크
    * 개발자가 +를 사용했으므로 개발자는 두값을 연결하고 싶어함
    * 자바스크립트는 암묵적으로 3을 문자열 “3”으로 변환 시행
    * \[1]도 암묵적으로 문자열 “1”로 변환 시행
    * 결국 “31” 문자열 결과 도출
* 타입스크립트는 유효하지 않은 작업을 발견하는 즉시 불평
  * ex) 3 + \[1] → 에러: ‘+’ 연산자를 ‘3’과 ‘number\[]’ 타입에 적용할 수 없음
    * 올바르지 않아보이는 연산 수행 시 타입스크립트가 바로 지적하며, 의도를 명시해야 그 지적을 무사히 통과할 수 있다.

⇒ 결론적으로.. 타입을 변활할 때는 명시적으로 해야 한다.

**언제 타입을 검사하는가?**

타입스크립트에서는 컴파일 타임에 코드 타입 확인 → 코드를 실행하지 않고도 이전 예제 코드에 에러가 있음을 바로 알 수 있다.

타입스크립트는 정적으로 코드를 분석해 이런 에러를 검출해 코드 실행 전에 알려준다.

```tsx
3 + [1]
[ts] Operator '+' cannot be applied to types '3' and 'number[]'. [2365]
```

**에러는 언제 검출되는가?**

*   자바스크립트는 런타임에 예외를 던지거나 암묵적 형변환 수행

    ⇒ 즉 프로그램을 실행해야만 어떤 문제가 있음을 확인 가능
* 타입스크립트는 컴파일 타임에 문법 에러와 타입 관련 에러를 모두 검출한다.
  * 코드편집기가 에러를 바로 보여준다.
  * 하지만, 스택 오버플로, 네트워크 연결 끊김 등 타입스크립트가 컴파일 타임에 검출할 수 없는 런타임 예외도 많다.

### 2.3 코드 편집기 설정

* VSCode 선호
* TSC 실행 위해 NodeJS 필요
  * NodeJS: 프로젝트 의존성이나 빌드를 관리하는 패키지 관리자 NPM을 포함

#### 2.3.1 tsconfig.json

| 옵션      | 설명                                                                      |
| ------- | ----------------------------------------------------------------------- |
| include | TSC가 타입스크립트 파일을 찾을 디렉토리                                                 |
| lib     | TSC가 코드 실행 환경에서 이용할 수 있다고 가정하는 API                                      |
| module  | TSC가 코드를 컴파일할 대상 모듈 시스템                                                 |
| outDir  | 생성된 자바스크립트 코드를 출력할 디렉토리                                                 |
| strict  | 유효하지 않은 코드를 확인할 때 가능한 한 엄격하게 검사. 해당 옵션 활용 시 코드가 적절하게 타입을 갖추도록 강제할 수 있다. |
| target  | TSC가 코드를 컴파일할 자바스크립트 버전                                                 |

```tsx
{
  "compilerOptions": {
    "lib": ["ES2020"],
    "module": "CommonJS",
    "outDir": "dist",
    "sourceMap": true,
    "strict": true,
    "target": "ES2020"
  },
  "include": ["src"]
}

```

#### 2.3.2 tslint.json

```tsx
{
    "defaultSeverity": "error",
    "extends": [
        "tslint:recommended"
    ],
    "jsRules": {},
    "rules": {},
    "rulesDirectory": []
}
```

#### 2.3.3 index.ts

src > index.ts



