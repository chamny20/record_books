---
icon: '6'
---

# 6장 - 고급 타입

### 6.1 타입 간의 관계

#### 6.1.1 서브타입과 슈퍼타입

\<aside>

**서브타입**

두 개의 타입 A와 B가 있고 B가 A의 서브타입이면 A가 필요한 곳에는 어디든 B를 안전하게 사용할 수 있다.

\</aside>

* 배열은 객체의 서브타입
* 튜플은 배열의 서브타입
* 모든 것은 any의 서브타입
* never는 모든 것의 서브타입
* Animal을 상속받는 Bird 클래스가 있다면 Bird는 Animal의 서브타입

***

* 객체를 사용해야 하는 곳에 배열도 사용 가능
* 배열을 사용해야 하는 곳에 튜플도 사용 가능
* any를 사용해야 하는 곳에 객체 사용 가능
* 어디에나 never 사용 가능
* Animal을 사용해야 하는 곳에 Bird도 사용 가능

\<aside>

**슈퍼타입**

두 개의 타입 A와 B가 있고 B가 A의 슈퍼타입이면 B가 필요한 곳에는 어디든 A를 안전하게 사용할 수 있다.

\</aside>

* 배열은 튜플의 슈퍼타입
* 객체는 배열의 슈퍼타입
* any는 모든 것의 슈퍼타입
* never는 누구의 슈퍼타입도 아니다.
* Animal은 Bird의 슈퍼타입

#### 6.1.2 가변성

* A <: B는 ‘A와 B와 같거나 B의 서브타입’
* A >: B는 ‘A와 B와 같거나 B의 슈퍼타입’

**\[형태와 배열 가변성]**

```tsx
// 서버로부터 받은 기존 사용자
type ExistingUser = {
	id: number
	name: string
}

// 아직 서버에 저장하지 않은 새 사용자
type NewUser = {
	name: string
}
```

```tsx
function deleteUser(user: {id?: number, name: string}) {
	delete user.id
}

deleteUser(existingUser)
```

기존 사용자라는 새로운 타입을 추가한 다음 이 타입의 사용자를 삭제해보자.

```tsx
type LegacyUser = {
	id?: number | string
	name: string
}

let legacyUser: LegacyUser = {
	id: '33333'
	name: 'chaemin'
}

deleteUser(legacyUser) // error
```

⇒ 타입스크립트는 다음처럼 동작한다.

* 어떤 형태를 요구할 때 건넬 수 있는 타입은, 요구되는 타입에 포함된 프로퍼티 각각에 대해 ‘<: 기대하는 타입’인 프로퍼티들을 가지고 있어야 한다.
* 기대하는 프로퍼티 타입의 슈퍼타입인 프로퍼티가 있다면 건넬 수 없다.
* 타입과 관련해 타입스크립트 형태는 그들의 프로퍼티 타입에 **공변한다**고 말한다.

즉, 객체 B에 할당할 수 있는 객체 A가 있다면 ‘객체 A의 각 프로퍼티 <: B의 대응 프로퍼티’라는 조건을 만족해야 한다.

**`[가변성의 4가지 종류]`**

* 불변
* 공변
* 반변
* 양변

**\[함수 가변성]**

1. A의 this 타입을 따로 지정하지 않으면 ‘A의 this 타입 >: B의 this 타입’이다.
2. ‘A의 각 매개변수 >: B의 대응 매개변수’
3. ‘A의 반환타입 <: B의 반환 타입’

```tsx
class Animal { }
class Bird extends Animal {
	chirp() {}
}
class Crow extends Bird {
	caw() {}
}
```

⇒ Crow <: Bird <: Animal 조건 성립

```tsx
chirp(new Animal) // error: 인수 Animal 타입을 Bird 타입에 할당할 수 없음

chirp(new Bird)
chirp(new Crow)
```

\<aside>

함수의 반환 타입은 공변, 즉 함수가 다른 함수의 서브타입이라면 ‘서브타입 함수의 반환 타입 <: 다른 함수의 반환 타입’을 만족해야 한다.

\</aside>

```tsx
function clone(f: (b: Bird) => Bird): void {
	let parent = new Bird
	let babyBird = f(parent)
	babayBird.chirp()
}
```

* 매개변수 타입의 관계는 어떨까?

```tsx
function animalToBird(a: Animal): Bird {
	// ...
}
clone(animalToBired) // ok

function crowToBird(c: Crow): Bird {
	// ...
}
clone(crowToBird) // error
```

⇒ 함수를 다른 함수에 할당하려면 ‘this를 포함한 매개변수 타입 >: 할당하려는 함수의 대응 매개변수 타입’ 조건을 만족해야 한다.

\<aside>

함수의 매개변수, this 타입은 반변이다.

한 함수가 다른 함수의 서브타입이라면 ‘서브타입 함수의 매개변수와 this 타입 >: 다른 함수의 대응하는 매개변수’라는 조건을 만족해야 한다.

\</aside>

#### 6.1.3 할당성

‘A를 B에 할당할 수 있는가?’라는 질문이 나오면.. 몇 가지 규칙에 따라 처리한다.

* A <: B
  * 서브타입이 무엇인지 정의할 뿐
  * A가 B의 서브타입이면 B가 필요한 곳에는 A를 사용할 수 있다.
* A는 any
  * 예외를 설명하며 자바스크립트 코드와 상호 운용할 때 유용하다.

#### 6.1.4 타입 넓히기

핵심 개념! 타입 넓히기\~

* 타입스크립트는 타입을 정밀하게 추론하기보다는 일반적으로 추론한다.
* let이나 var로 값을 바꿀 수 있는 변수를 선언하면 그 변수의 타입이 리터럴 값에서 리터럴 값이 속한 기본 타입으로 넓혀진다.

```tsx
let a = 'x' // string
let b = 3 // number

enum E {x, y, z}
let e = E.x // E

const a = 'x' // 'x'
const b = 3 // 3

let a: 'x' = 'x' // 'x'
let b: 3 = 3 // 3
var c: true = true // true

const a = 'x' // 'x'
let b = a // string

const c: 'x' = 'x'
let d = c // 'x'

let a = null // any
a = 3 // any
a = 'b' // any
```

```tsx
function x() {
	let a = null
	a = 3
	a = 'b'
	return a
}

x() // string
```

**\[const 타입]**

```tsx
let a = {x: 3} // {x: number}
let c = {x: 3} as const // {readonly x: 3}
```

const를 사용하면 타입 넓히기가 중지되며 멤버들까지 자동으로 readonly가 된다.

```tsx
let d = [1, {x: 2}] // (number | {x: number})[]
let e = [1, {x: 2}] as const // readonly [1, {readonly x: 2}]
```

타입스크립트가 변수를 가능한 한 좁은 타입으로 추론하길 원한다면 as const를 이용하자.

**\[초과 프로퍼티 확인]**

```tsx
type Options = {
	baseURL: string
	cacheSize?: number
	tier?: 'prod' | 'dev'
}

class API {
	constructor(private options: Options) { }
}

new API({
	baseURL: '...'
	tier: 'prod'
})

new API({
	baseURL: '...'
	tierr: 'prod'
	// error 오타~
	...
})
```

⇒ 초과 프로퍼티 확인 기능 덕분에 발견 가능

⇒ 신선한 객체 리터럴 타입 T를 다른 타입 U에 할당하려는 상황에서 T가 U에는 존재하지 않는 프로퍼티를 가지고 있다면 타입스크립트는 이를 에러로 처리한다.

* 신선한 객체 리터럴 타입
  * 타입스크립트가 객체 리터럴로부터 추론한 타입

#### 6.1.5 정제

타입스크립트는 심벌 수행의 일종인 흐름 기반 타입 추론을 수행한다.

즉, 타입 검사기는 typeof, instanceof, in 등의 타입 질의뿐 아니라, 마치 프로그래머가 코드를 읽듯 if, ?, ||, switch 같은 제어 흐름 문장까지 고려하여 타입을 정제한다.
