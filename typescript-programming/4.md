---
icon: '4'
---

# 4장 - 함수

이번 장에서는 다음의 내용을 살펴본다.

* 타입스크립트에서 함수를 선언하고 실행하는 다양한 방법
* 시그니처 오버로딩
* 다형적 함수
* 다형적 타입 별칭

***

## 4.1 함수 선언과 호출

* 자바스크립트에서 함수는 일급 객체
  * 객체를 다루듯이 함수를 변수에 할당하거나, 함수를 다른 함수로 전달, 함수에서 함수 반환, 객체와 프로토타입에 할당, 함수에 프로퍼티 기록, 함수에 기록된 프로퍼티 읽기 등의 작업 수행 가능
* 타입스크립트는 이 모든 것을 자신의 풍부한 타입 시스템에 녹여냈다.

```jsx
function add(a: number, b: number) {
	return a + b;
}
```

→ 타입스크립트는 항상 함수의 본문에서 사용된 타입들을 추론하지만 특별한 상황을 제외하면 매개변수 타입은 추론하지 않는다.

```jsx
function add(a: number, b: number): number {
	return a + b;
}
```

→ 반환 타입은 자동으로 추론하지만 원하면 명시할 수 있다.

\*실무에서는 타입스크립트가 반환 타입을 추론하도록 하는 게 보통이다. 타입스크립트가 해줄 수 있는 일을 개발자가 직접 할 필요가 없기 때문이다.

* 타입스크립트는 최소 5가지의 함수 선언 방법을 지원

```jsx
// 함수 표현식
function greet(name: string){
	return 'hello ' + name
}

// 함수 표현식
const greet2 = function(name: string){
	return 'hello ' + name
}

// 화살표 함수 표현식
const greet3 = (name: string) => {
	return 'hello ' + name
}

// 단축형 화살표 함수 표현식
const greet4 = (name: string) => 'hello ' + name

// 함수 생성자
const greet5 = new Function('name', 'return "hello " + name')
```

→ 타입스크립트는 함수 생성자를 제외한 모든 문법을 안전하게 지원하며, 이 모든 문법은 보통 매개변수 타입의 필수 어노테이션, 반환 타입의 선택형 어노테이션에 적용하는 것과 같은 규칙을 따른다.

```jsx
add(1, 2) // 3으로 평가
greet('Crystal') // 'hello Crystal'로 평가

add(1, 'a') // error: a의 인수 타입은 number 매개 변수 타입에 할당할 수 없음
```

### 4.1.1 선택적 매개변수와 기본 매개변수

객체와 튜플 타입에서처럼 함수에서도 `?`를 이용해 선택적 매개변수를 지정할 수 있다.

```jsx
function log(message: string, userId?: string ){
	let time = new Date().toLocaleTimeString()
	console.log(time,message,userId || 'Not signed in')
}

log('Page loaded') // 오후 9:40:15 Page loaded Not signed in

log('User signed in','ellen') // 오후 9:40:15 User signed in ellen 
```

아래와 같이 매개변수에 기본값을 지정할 수도 있다.

```jsx
function log(message: string, userId = 'Not signed in' ){
	let time = new Date().toLocaleTimeString()
	console.log(time, message, userId)
}

log('User clicked on a button', 'da763be')
log('User signed out')
```

⇒ userId에 기본값을 제공하므로 선택형 마크와 타입을 지정할 필요가 없어진다. 타입스크립트는 기본값으로 매개변수의 타입을 자동으로 추론해주기 때문에 덕분에 코드가 간결해지고 읽기 쉬워짐!

\*보통 실무에서는 선택적 매개변수보다 기본 매개변수를 더 자주 사용하게 된다.

### 4.1.2 나머지 매개변수

```jsx
function sum(numbers: number[]): number {
	return numbers.reduce((total, n) => total + n, 0)
}

sum([1, 2, 3]) // 6으로 평가
```

⇒ 인수를 여러 개 받는 함수라면 그 목록을 배열 형태로 건넬 수도 있다.

만약 고정 인자 API가 아니라 가변 인자 API가 필요할 경우라면?

⇒ 자바스크립트에서는 런타임이 함수에 자동으로 arguments를 정의해 개발자가 함수로 전달할 인수 목록을 할당한다. arguments는 일종의 배열이므로, .reduce와 같은 내장 기능을 사용하려면 먼저 진짜 배열로 변환해야 한다.

```jsx
function sumVariadic(): number {
	return Array.from(arguments).reduce((total, n) => total + n, 0)
}

sumVariadic(1, 2, 3); // 6으로 평가
```

⇒ 하지만 안전하지 않은 형태. n과 total 모두를 any 타입으로 추론

어떻게 해결할 수 있을까?

⇒ rest parameters로 문제 해결 가능

```jsx
function sumVariadicSafe(...numbers: number[]): number {
	return numbers.reduce((total, n) => total + n, 0)
}

sum([1, 2, 3]) // 6으로 평가
```

⇒ 안전하지 않은 arguments를 사용하는 대신 나머지 매개변수를 이용해 sum 함수가 안전하게 임의의 인수를 받게 만든다.

### 4.1.3 call, apply, bind

```jsx
function add(a: number, b: number): number {
	return a + b
}

add(10, 20) // 30
add.apply(null, [10, 20]) // 30
add.call(null, 10, 20) // 30
add.bind(null, 10, 20)() // 30
```

* apply
  * 함수 안에서 값을 this로 한정(bind) → 두 번째 인수를 펼쳐 함수에 매개변수로 전달
* call
  * apply랑 같은 기능을 제공하지만 인수를 펼쳐 전달하지 않고 순서대로 전달
* bind
  * this 인수를 함수의 인수 목록으로 한정
  * bind는 함수를 호출하지 않고 새로운 함수를 반환하는데, 개발자는 ()나 .call을 이용해 반환된 함수를 호출하거나 .apply로 아직 한정하지 않은 매개변수를 추가로 전달 가능

\<aside> 💡

**strictBindCallApply**

.call, .apply, .bind를 안전하게 사용하려면 tsconfig.json에서 strictBindCallApply를 활성화해야 한다.

\</aside>

### 4.1.4 this의 타입

개발팀은 보통 클래스 메서드를 제외한 다른 모든 곳에서 this 사용을 금한다.

this가 자주 문제를 일으키는 이유는?

알아보자\~

```jsx
let x = {
	a() {
		return this
	}
}
x.a() // a()의 바디 안에서 this는 객체 x이다.
```

만약, 호출이 일어나기 전 어느 시점에서 a를 다시 할당하면 결과가 달라진다.

```jsx
let a = x.a
a() // 이제 a()의 바디 안에서 this는 정의되지 않은 상태
```

예제를 보자. (날짜의 타입을 포매팅하는 유틸리티 함수)

```jsx
function fancyDate() {
	return ${this.getDate()}/${this.getMonth()}/${this.getFullYear()}
}

fancyDate.call(new Date) // "4/14/2005"로 평가
fancyDate() // 처리되지 않은 타입에러: this.getDate는 함수가 아님 (런타임 예외)
```

이 버전의 fancyDate를 호출하려면 this로 한정할 Date를 제공해야 한다.

함수에서 this를 사용할 때는 항상 기대하는 this 타입을 함수의 첫 번째 매개변수로 선언하자.

```jsx
function fancyDate(this: Date) {
	return ${this.getDate()}/${this.getMonth()}/${this.getFullYear()}
}
```

이렇게 되면 런타임 에러 대신 컴파일 타임에 경고를 확인할 수 있다!

```jsx
fancyDate.call(new Date) // "6/13/2008"
fancyDate() // 에러: void 타입의 this를 메서드에 속한 'Date' 타입의 'this'에 할당할 수 없음
```

### 4.1.5 제너레이터 함수

* 제너레이터 함수
  * 여러 개의 값을 생성하는 편리한 기능을 제공
  * 값을 생산하는 속도도 정교하게 조절 가능
  * 무한의 목록 생성하기같은 까다로운 기능 제공 가능

```jsx
function* createFibonacciGenerator() { // *표시가 제너레이터. -> 이터러블 반복자 반환
	let a = 0
	let b = 1
	while (true) {
		yield a;
		[a, b] = [b, a + b]
	}
}

let fibonacciGenerator = createFibonacciGenerator() // IterableIterator<number>
fibonacciGenerator.next() // {value: 0, done: false}
fibonacciGenerator.next() // {value: 1, done: false}
fibonacciGenerator.next() // {value: 2, done: false}
fibonacciGenerator.next() // {value: 3, done: false}
fibonacciGenerator.next() // {value: 4, done: false}
fibonacciGenerator.next() // {value: 5, done: false}
```

1. 함수명 앞에 붙은 \*는 해당 함수가 제너레이터임을 의미한다. 제너레이터를 호출하면 이터러블 반복자가 반환된다.
2. 제너레이터는 영구적으로 값을 생성할 수 있다.
3. 제너레이터는 yield라는 키워드로 값을 방출한다. 소비자가 제너레이터에 다음 값을 요청하면, yield를 이용해 결과를 소비자에게 보내고, 소비자가 다음 값을 다시 요청하기 전까지는 실행을 중지한다. 따라서 while(true) 루프가 영원히 실행되다가 비정상 종료되는 상황이 일어나지 않는다.
4. 다음 피보나치 숫자를 계산하기 위해 a에 b를, b에 a + b를 한번에 다시 할당한다.

* generator에 next를 호출할 때마다 다음 피보나치 값을 계산해서 결과를 방출한다.

### 4.1.6 반복자

반복자와 제너레이터는 상생관계이다. 제너레이터로 값의 스트림을 생성할 수 있고 반복자로 생성된 값을 소비할 수 있기 때문이다.

* `iterable`: 반복할 수 있는
  * Symbol.iterator라는 프로퍼티를 가진 모든 객체
* `iterator`: 반복자
  * next라는 메서드(value, done 두 프로퍼티를 가진 객체를 반환)를 정의한 객체

Symbol.iterato와 next를 구현하는 객체를 만들어 반복자나 이터러블을 직접 정의할 수 있다.

* 예제 - 1\~10 반복하는 반복자를 정의하는 예시

```jsx
let numbers = {
	*[Symbol.iterator]() {
		for (let n=1; n<=10; n++) {
			yield n
		}
	}
}
```

위 코드에서 numbers의 타입 추론은 아래와 같이 확인할 수 있다.

```jsx
let numbers: {
	[Symbol.iterator](): IterableIterator<number>;
}
```

### 4.1.7 호출 시그니처

함수의 전체 타입을 표현하는 방법을 알아보자.

```jsx
function sum(a: number, b: number): number {
	return a + b
}
```

sum은 무슨 타입일까? ⇒ Function

음.. 다른 방법이 있나? 다음과 같이 표현해보자.

**`(a: number, b: number) ⇒ number`**

**⇒ 이 코드는 타입스크립트의 함수 타입 문법으로, 호출 시그니처(call signature) 또는 타입 시그니처라 부른다.**

* 함수 호출 시그니처
  * 타입 수준 코드, 즉 값이 아닌 타입 정보만 포함
  * 함수 호출 시그니처는 바디를 포함하지 않아 타입스크립트가 타입을 추론할 수 없으므로 반환 타입을 명시해야 한다.

\<aside> 💡

**타입 수준 코드와 값 수준 코드**

해당 책에서의 정의는..

* 타입 수준 코드: 타입과 타입 연산자를 포함하는 코드를 의미
* 값 수준 코드: 그 밖의 모든 것

\*bold처리 코드가 타입 수준 코드

```jsx
function area(radius: **number): number | null** {
	if (radius < 0) {
		return null
	}
	return Math.PI * (radius ** 2)
}

let r: **number** = 3
let a = area(r)
if (a !== null) {
	console.info('result:', a)
}
```

\</aside>

호출 시그니처와 구현의 관계를 더 구체적으로 확인하자.

```jsx
type Log = (message: string, userId?: string) => void

let log: Log = (
	message,
	userId = 'Not signed in'
) => {
	let time = new Date().toISOString()
	console.log(time, message, userId)
}
```

* 함수 표현식 log를 선언하면서 Log타입임을 명시했다.
* 매개변수의 타입을 다시 지정할 필요는 없다. (당연한 사실)
* userId에 기본값을 지정. 호출 시그니처는 값을 포함할 수 없으므로 Log에서는 userId의 타입은 지정할 수 있지만 기본값은 지정할 수 없기 때문이다.
* Log 타입에서 반환 타입을 void로 이미 지정했으므로 반환 타입은 다시 지정할 필요가 없다.

### 4.1.8 문맥적 타입화

위 예제처럼, 이미 log 타입을 Log로 지정했으므로 타입스크립트가 message 타입을 string으로 추론할 수 있기 때문이다. ⇒ 이는 **문맥적 타입화**라는 타입 스크립트의 강력한 추론 기능

```jsx
function times(
	f: (index: number) => void,
	n: number
) {
	for (let i=0; i<n; i++) {
		f(i)
	}
}
```

해당 함수는 콜백 함수 f를 n번 호출하며, 현재의 인덱스를 f의 인수로 전달한다.

```jsx
times(n => console.log(n), 4)
```

times 시그니처에서 f의 인수 index를 number로 선언했으므로 타입스크립트는 문맥상 n이 number임을 추론할 수 있다.

### 4.1.9 오버로드된 함수 타입

```tsx
// 단축형 호출 시그니처
type Log = (message: string, userId?: string) => void

// 전체 호출 시그니처
type Log = {
	(message: string, userId?: string): void
}
```

⇒ 두 코드는 문법만 조금 다를 뿐 모든 면에서 같다.

⇒ Log 함수처럼 간단한 상황이라면 단축형을 주로 활용하되 더 복잡한 함수라면 전체 시그니처를 사용하는 것이 좋을 때도 있다.

\<aside> 💡

**오버로드된 함수**: 호출 시그니처가 여러 개인 함수

\</aside>

* 오버로드된 함수 시그니처를 이용하면 표현력 높은 API를 설계할 수 있다.

***

**예제: Reserve라는 휴가 예약 API 설계해보자.**

* 타입 지정

```tsx
type Reserve = {
	(from: Date, to: Date, destination: string): Reservation
}
```

* Reserve 구현 코드

```tsx
let reserve: Reserve = (from, to, destination) => {
	// ...
}
```

from, to → 날짜

destination → 목적지

편도 여행을 지원하도록 만들 수도 있다.

```tsx
type Reserve = {
	(from: Date, to: Date, destination: string): Reservation
	(from: Date, destination: string): Reservation
}
```

위처럼 구현하게 되면, 이전에 reserve를 구현한 코드에서 에러를 발생시킨다.

⇒ 타입스크립트가 호출 시그니처 오버로딩을 처리하는 방식 때문에 발생

⇒ f를 구현하는 관점에서는 단일한 구현으로 조합된 타입을 나타낼 수 있어야 한다.

```tsx
let reserve: Reserve = (
	from: Date,
	toOrDestination: Date | string,
	destination?: string	
)
```

⇒ 구현된 시그니처는 두 개의 오버로드 시그니처를 수동으로 결합한 결과와 같다.

```tsx
let reserve: Reserve = (
	from: Date,
	toOrDestination: Date | string,
	destination?: string	
) => {
	if (toOrDestination instanceof Date && destination !== undefined) {
		// 편도 여행 예약
	} else if (typeof toOrDestiantion === 'string') {
		// 왕복 여행 예약
	}
}
```

\<aside> 💡

**오버로드 시그니처는 구체적으로 유지하자**

* 오버로드된 함수 타입을 선언할 때는 각 오버로드 시그니처(Reserve)를 구현의 시그니처(reserve)에 할당할 수 있어야 한다.
* 오버로드를 사용할 때는 함수를 쉽게 구현할 수 있도록 가능한 한 구현의 시그니처를 특정하는 것이 좋다.
  * ex. any 대신 Date, any 대신 Date | string 유니온을 사용할 수 있다. \</aside>
* **브라우저 DOM API에서 유용하게 활용되는 오버로드**

오버로드된 호출 시그니처는 이 `createElement`의 동작을 구현하기에 이상적인 메커니즘이다.

```tsx
type CreateElement = {
	(tag: 'a'): HTMLAnchorElement
	(tag: 'canvas'): HTMLCanvasElement
	(tag: 'table'): HTMLTableElement
	(tag: string): HTMLElement // 최신 태그명을 전달하면 일반적인 HTMLElement로 반환
}
let createElement: CreateElement = (tag: string): HTMLElement => { 
	// ...
}
```

⇒ 구현의 매개변수는 `‘a’ | ‘canvas’ | ‘table’ | string`을 모두 지원해야 한다.

## 4.2 다형성

구체 타입이란?

지금까지 살펴본 타입들이 모두 구체 타입이다.

* boolean, string, Date\[], {a: number} | {b: string}, (numbers: number\[]) ⇒ number

⇒ 기대하는 타입을 정확하게 알고 있고, 실제 이 타입이 전달되었는지 확인할 때는 구체 타입이 유용하다.

```tsx
function filter(array, f) {
	let result = []
	for (let i=0; i<array.length; i++) {
		let item = array[i]
		if (f(item)) {
			result.push(item)
		}
	}
	return result
}

filter([1, 2, 3, 4], _ => _ < 3) // [1, 2]로 평가
```

filter의 전체 타입 시그니처를 만들어보자.

```tsx
type Filter = {
	(array: unknown, f: unknown) => unknown[]
}
```

이제 다시 number type이라고 가정해 unknown을 number로 바꾼다.

```tsx
type Filter = {
	(array: number[], f: (item: number) => boolean): number[]
}
```

이제 문자열도 거를 수 있도록 오버로드를 이용해 함수를 확장해보자.

```tsx
type Filter = {
	(array: number[], f: (item: number) => boolean): number[]
	(array: string[], f: (item: string) => boolean): string[]
}
```

그런데.. 객체 배열을 추가하면? ⇒ 문제가 발생한다.

```tsx
let names = [
	{ firstName: 'beth' },
	{ firstName: 'caitlyn' },
	{ firstName: 'xin' }
]

let result = filter(
	names,
	_ => _.firstName.startsWith('b')
) // error: firstName property는 object 타입에 존재하지 않음

result[0].firstName // error: firstName 프로퍼티는 object 타입에 존재하지 않음
```

⇒ 여기서 왜 에러가 나냐?

⇒ 타입스크립트에 filter로 숫자, 문자열, 객체의 배열을 전달할 것이라고 선언했다. 그다음 객체 배열을 전달했는데, object는 객체의 실제 형태에 대해서는 어떤 정보도 알려주지 않는다!

⇒

## 4.3 타입 주도 개발

## 4.4 마치며
