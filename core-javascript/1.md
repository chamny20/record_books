# 1️⃣ 1장 - 데이터 타입

### ▣ 01장: 데이터 타입

#### 1-1 데이터 타입의 종류

* **기본형(primitive type) - 불변값**
  * Number, String, Boolean, null, undefined, Symbol
* **참조형(reference type) - 가변값**
  * Object
    * Array, Function, Date, RegExp, Map, WeakMap, Set, WeakSet
* 기본형과 참조형을 구분하는 기준
  *   **기본형 - 값이 담긴 주소값을 바로 복제한다.**

      ```jsx
      let a = 10;
      let b = a; // a의 값을 그대로 복사하여 b에 저장한다.

      b = 20; // b의 값을 변경하면

      console.log(a); // 10 (a는 변하지 않는다.)
      console.log(b); // 20
      ```

      ⇒ a와 b는 독립적인 값

      ⇒ b를 변경해도 a에는 영향을 주지 않는다.

      ⇒ “값이 담긴 주소값을 바로 복제한다”는 의미가 바로 이거!
  *   **참조형 - 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제한다.**

      ```jsx
      let obj1 = { name: "Alice" };
      let obj2 = obj1; // obj1이 가리키는 주소값을 obj2도 가리키도록 복사

      obj2.name = "Bob"; // obj2를 변경

      console.log(obj1.name); // "Bob"
      console.log(obj2.name); // "Bob"
      ```

      ⇒ obj1과 obj2가 같은 객체를 가리킨다.

      ⇒ obj2의 값을 변경하면 obj1에서도 같은 변경이 반영된다.

      ⇒ “값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제한다”는 의미가 이거!

#### 1-2 데이터 타입에 관한 배경지식

**\_\_\_1-2-1 메모리와 데이터**

* bit: 0 or 1만 표현 가능한 하나의 메모리 조각
  * 각 비트는 **고유한 식별자**를 통해 위치를 확인 → 1byte = 8bit
* C/C++, JAVA 등의 정적 타입 언어는 메모리의 낭비를 최소화하기 위해 데이터 타입별로 할당할 메모리 영역을 2바이트, 4바이트 등으로 나누어 정해놓음
*   자바스크립트는 상대적으로 메모리 관리에 대한 압박에서 자유로운 상황 속에서 탄생

    ⇒ 숫자의 경우 따로 구분하지 않고 64비트, 즉 8byte를 확보한다.

    ⇒ 개발자가 형변환 걱정할 일이 줄어들게 됨
* 모든 데이터는 바이트 단위의 식별자, 더 정확하게는 **메모리 주소값**을 통해 서로 구분하고 연결 가능

**\_\_\_1-2-2 식별자와 변수**

\*\*변수와 식별자 잘 구분하기

* `변수`: 변할 수 있는 수, 변할 수 있는 무언가(data), variable
* `식별자`: 어떤 데이터를 식별하는 데 사용하는 이름, 즉 변수명

#### 1-3 변수 선언과 데이터 할당

**\_\_\_1-3-1 변수 선언**

`var a;` ⇒ 보통 이렇게 변수 선언한다.

의미는? ⇒ 변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다.

즉, 변수란 결국 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇

* `var a;` 의 실행 과정
  * 명령을 받은 컴퓨터는 메모리에서 비어있는 공간 하나 확보 (임의로 1003번으로 정하자)
  * 이 공간의 이름(식별자)을 a라고 지정
  *
    *
      *
        * 여기까지가 **변수 선언 과정** - - - - -

**\_\_\_1-3-2 데이터 할당**

```jsx
var a ; // 변수 a 선언
a = 'abc'; // 변수 a에 데이터 할당

var a = 'abc'; // 변수 선언과 할당을 한 문장으로 표현
```

* 선언과 할당을 나누어 명령하든, 한 문장으로 명령하든, 자바스크립트 엔진은 결국 같은 동작 수행
* 할당 과정 → a라는 이름을 가진 주소 검색 후, 그곳에 문자열 할당

\[데이터 할당에 대한 메모리 영역의 변화] - 변수 영역과 데이터 영역 잘 보기

![image.png](attachment:ad5492b3-92ed-4450-a1f7-f4db5f692af6:image.png)

1. 변수 영역에서 빈 공간(@1003) 확보
2. 확보한 공간의 식별자를 a로 지정
3. 데이터 영역의 빈 공간(@5004)에 문자열 ‘abc’ 저장
4. 변수 영역에서 a라는 식별자를 검색 (@1003)
5. 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입

![image.png](attachment:584e90f9-57b0-4ec7-88a4-3f1b71e32d4d:image.png)

→ 문자열 ‘abc’의 마지막에 ‘def’를 추가하라고 하면 컴퓨터는 앞서 ‘abc’가 저장된 공간에 ‘abcdef’를 할당하는 대신 **‘abcdef’라는 문자열을 “새로” 만들어 별도의 공간에 저장하고, 그 주소를 변수 공간에 연결**한다.

⇒ 즉, 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아진다.

⇒ 한 단계 더 거치는 이유: 데이터 변환을 자유롭게 하고, 메모리를 효율적으로 관리하기 위함

#### 1-4 기본형 데이터와 참조형 데이터

**\_\_\_1-4-1 불변값**

* 변수와 상수를 구분하는 성질 ⇒ `“변경 가능성”`
  * 바꿀 수 있으면 변수
  * 바꿀 수 없으면 상수
  * 변수와 상수를 구분 짓는 변경 가능성의 대상은 **변수 영역 메모리**이다.
  * 반면, 불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역 메모리**이다.

```jsx
var a = 'abc';
a = a + 'def'; // 새로운 문자열 'abcdef'를 만들어 그 주소를 변수 a에 저장
// 즉, abc와 abcdef는 완전히 별개의 데이터

var b = 5; // 컴퓨터는 일단 데이터 영역에서 5를 찾고, 
// 없으면 데이터 공간을 하나 만들어 저장한다.
// 그 주소를 b에 저장한다.
var c = 5; // 다시 같은 수인 5를 할당하려고 한다. 컴퓨터는 데이터 영역에서 5를 찾는다.
// 이미 만들어놓은 값이 있으니 그 주소를 재활용한다.
b = 7; // b의 값을 7로 바꾸고자 한다.
// 그럼 기존에 저장된 5 자체를 7로 바꾸는 것이 아니라!!!!
// 기존에 저장했던 7을 찾아서 있으면 재활용하고, 없으면 새로 만들어서 b에 저장한다.
// 결국, 5와 7 모두 다른 값으로 변경할 수 없다.
```

⇒ 즉, 변경은 새로 만드는 동작을 통해서만 이루어진다.

⇒ 이것이 바로 불변값의 성질

⇒ 한번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다.

**\_\_\_1-4-2 가변값**

* 참조형 데이터의 할당

```jsx
var obj1 = {
	a: 1,
	b: 'bbb',
};
```

![image.png](attachment:69b83a6b-32d3-4487-98ca-93ed90dd54af:image.png)

1. 컴퓨터는 우선 변수 영역의 빈 공간(@1002)을 확보하고, 그 주소의 이름을 obj1로 지정한다.
2. 임의의 데이터 저장 공간(@5001)에 데이터를 저장하려고 보니 여러 개의 프로퍼티로 이루어진 데이터 그룹임을 확인. 이 그룹 내부 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련 → 그 영역의 주소를 @5001에 저장
3. @7103 및 @7014에 각각 a와 b라는 프로퍼티 이름을 지정
4. 데이터 영역에서 숫자 1 검색 → 검색 결과가 없으므로 임의로 @5003에 저장 → 이 주소를 @7013에 저장 → 문자열 ‘bbb’ 역시 임의로 @5004에 저장하고, 이 주소를 @7104에 저장

* 기본형 데이터와의 차이는 ‘객체의 변수(프로퍼티) 영역’이 별도로 존재한다는 점
* 객체가 별도로 할애한 영역은 변수 영역일 뿐, 데이터 영역은 기존의 메모리 공간을 그대로 활용하고 있다. **즉, 데이터 영역에 저장된 값은 모두 불변값**
* **그러나, 변수에는 다른 값을 얼마든지 대입할 수 있다. ⇒ 즉, 참조형 데이터는 불변하지 않다(가변값이다)라고 하는 것.**

```jsx
var obj1 = {
	a: 1,
	b: 'bbb',
};
obj1.a = 2; // obj1의 a 프로퍼티에 숫자 2를 할당하려고 할 때
```

→ 데이터 영역에서 숫자 2 검색

→ 검색 결과가 없으므로 빈 공간인 @5005에 저장, 이 주소를 @7103에 저장

![image.png](attachment:261eef54-0d6c-4572-88df-3148a4cf51b6:image.png)

⇒ 변수 obj1이 바라보고 있는 주소는 계속 @5001로, 변하지 않는다.

**⇒ 즉 “새로운 객체”가 만들어진 것이 아니라 기존의 객체 내부의 값만 바뀐 것**

* 참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우
  * 중첩 객체(nested object)라고 함

```jsx
var obj = {
	x: 3,
	arr: [3, 4, 5]
};
```

1. 컴퓨터는 우선 변수 영역의 빈 공간(@1002)을 확보하고, 그 주소의 이름을 obj로 지정
2. 임의의 데이터 저장공간(@5001)에 데이터를 저장하려는데, 이 데이터는 여러 개의 변수와 값들을 모아놓은 그룹(객체)이다. (위랑 똑같이) 그룹의 각 변수(프로퍼티)들을 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소를 @5001에 저장
3. @7103에 이름 x를, @7104에 이름 arr를 지정
4. 데이터 영역에서 숫자 3 검색 → 검색 결과 없기 때문에 임의로 @5002에 저장, 이 주소를 @7103에 저장
5. 배열 역시 똑같이 → @7104에 저장 → 배열이기 때문에 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소를 @7104에 저장
6. 배열의 요소가 총 3개이므로 3개의 변수 공간 확보 → 각각 인덱스 부여 (0, 1, 2)
7. 데이터 영역에서 숫자 3 검색해서 (@5002) 그 주소를 @8104에 저장
8. 데이터 영역에서 숫자 4 검색 → 없기 때문에 @5004에 저장, 이 주소를 @8015에 저장
9. 데이터 영역에서 숫자 5 검색 → 없기 때문에 @5005에 저장, 이 주소를 @8106에 저장

![image.png](attachment:40859250-c93d-474b-9673-965623bb6dc6:image.png)

* 만약, `obj.arr[1]` 을 검색하고자 한다면? 메모리에서는 다음과 같은 검색 과정을 거친다.
  * obj 검색 1: obj라는 식별자를 가진 주소를 찾는다. (@1002)
  * obj 검색 2: 값이 주소이므로 그 주소로 이동한다. (@5001)
  * obj 검색 3: 값이 주소이므로 또 그 주소로 이동한다. (@7013 \~ ?)
  * obj.arr 검색 1: arr이라는 식별자를 가진 주소를 찾는다. (@7104)
  * obj.arr 검색 2: 값이 주소이므로 그 주소로 이동한다. (@5003)
  * obj.arr 검색 3: 값이 주소이므로 또 그 주소로 이동한다. (@8104 \~ ?)
  * obj.arr\[1] 검색 1: 인덱스 1에 해당하는 주소를 찾는다. (@8105)
  * obj.arr\[1] 검색 2: 값이 주소이므로 그 주소로 이동한다. (@5004)
  * obj.arr\[1] 검색 3: 값이 숫자형 데이터이므로 4를 반환한다.
* **참조 카운트**: 어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수
  * 참조 카운트가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 된다.
  * GC는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때마다 자동으로 수거 대상들을 수거한다. 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 된다.
  *   참조 카운트가 2개 이상이면 어떻게 될까?

      ```jsx
      let obj1 = { name: "Alice" }; // 객체 생성 (참조 카운트: 1)

      let obj2 = obj1; // obj1이 참조하는 객체를 obj2도 참조 (참조 카운트: 2)

      let obj3 = obj1; // obj1이 참조하는 객체를 obj3도 참조 (참조 카운트: 3)

      console.log(obj1.name); // "Alice"
      console.log(obj2.name); // "Alice"
      console.log(obj3.name); // "Alice"
      ```

      만약 다시 감소한다면?

      ```jsx
      obj1 = null; // 참조 해제 (참조 카운트: 2)
      obj2 = null; // 참조 해제 (참조 카운트: 1)
      obj3 = null; // 참조 해제 (참조 카운트: 0) → GC의 수거 대상!
      ```

**\_\_\_1-4-3 변수 복사 비교**

이제 기본형 데이터와 참조형 데이터의 차이를 확인해볼 차례.

* 변수 복사

```jsx
var a = 10; // 기본형 데이터
var b = a;

var obj1 = { c: 10, d: 'ddd' }; // 참조형 데이터
var obj2 = obj1;
```

![image.png](attachment:89479711-a91b-4d08-89ce-093d42ef9fac:image.png)

⇒ 변수 복사하는 과정은 모두 같은 주소를 바라보게 된다는 점에서는 동일하다.

*   **변수 복사 이후 값 변경 결과 비교 - 객체의 프로퍼티 변경 시**

    ```jsx
    b = 15;
    obj2.c = 20;
    ```

    ![image.png](attachment:1e8ac1f7-80f4-4ad8-9251-b9cd72bf2997:image.png)

    ⇒ 기본형 데이터: 값이 변경된다.

    ⇒ 참조형 데이터: 값은 변경되지 않음! ⇒ 주소가 @5001에서 @5005로 바뀜
*   변수 복사 이후 값 변경 결과 비교 - 객체 자체를 변경했을 때

    ```jsx
    b = 15;
    obj2.c = { c: 20, d: 'ddd'};
    ```

    ![image.png](attachment:331d9b52-cf78-4832-b91a-1d1b761ba3d7:image.png)

#### 1-5 불변 객체(immutable object)

**\_\_\_1-5-1 불변 객체를 만드는 간단한 방법**

기존 데이터는 변하지 않고 내부 프로퍼티를 변경할 필요가 있을 때마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정하거나 자동으로 새로운 객체를 만드는 도구를 활용하면 불변성 확보 가능

* 하드코딩으로 객체 입력

```jsx
var user = {
	name: 'james',
  gender: 'male'
}

var changeName = function (user, newname) {
	return {
    	name: newName,
      gender: user.gender
  }
}
```

* 얕은 복사(기존 정보를 복사해서 새로운 객체를 반환하는 함수)

```jsx
var copyObj = function (target) {
	var result = {};
    for (var prop in target) {
    	result[prop] = target[prop]
    }
    return result;
}
```

새로운 객체에 원본 객체 속 바꾸고자 하는 값과 변경하지 않는 기존 값을 넣으면 된다. 이때 기존 값이 기본형 데이터일 경우에는 그대로 복사하고, 참조형 데이터일 경우에는 다시 그 내부 프로퍼티를 복사하면 된다.

**\_\_\_1-5-2 얕은 복사와 깊은 복사**

* `얕은 복사`: 바로 아래 단계의 값만 복사하는 방법
  * 객체를 복사할 때, 기본형 데이터들은 값 자체를 복사하지만, 객체(참조형 데이터)는 주소값만 복사하는 방식
  * 즉, 중첩된 객체 내부는 복사되지 않고 원본을 그대로 참조하는 문제가 발생한다.
* `깊은 복사`: 내부의 모든 값들을 복사하는 방법
  * 객체 안에 있는 중첩된 객체까지 모두 새로운 객체로 복사하는 방법
  * 즉, 값 자체를 재귀적으로 복사하므로 원본과 복사본이 완전히 독립적으로 존재하게 된다.
* 얕은 복사 예시

```jsx
var copyObject = function (target) {
  var result = {}; // 새로운 객체 생성
  for (var prop in target) {
    result[prop] = target[prop]; // 속성 복사 (얕은 복사)
  } 
  return result;
}

var user = {
  name: 'Raccoon',
  favorite: { // 중첩된 객체 (참조형 데이터)
    fruit: 'apple',
    drink: 'coke',
    hobby: 'drive'
  }
}

var user2 = copyObject(user); // user 객체를 얕은 복사

// 1. 기본형 데이터 변경 (독립적)
user2.name = 'Hello';
console.log(user.name); // "Raccoon"
console.log(user2.name); // "Hello"
console.log(user.name === user2.name); // false

// 2. 참조형 데이터 변경 (공유됨)
user2.favorite.fruit = 'banana';
console.log(user.favorite.fruit);  // "banana" (원본도 바뀜!)
console.log(user2.favorite.fruit); // "banana"
console.log(user.favorite.fruit === user2.favorite.fruit); // true
```

⇒ 얕은 복사 시 단점은, 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티 복사 시 주소값만 복사한다. 따라서, 사본을 바꾸면 원본도 바뀌게 된다.

⇒ ✅ **이름(`name`)은 정상적으로 복사됨**

`name`은 **기본형 데이터(string)** 이므로 **값이 복사됨**.

따라서 `user2.name`을 변경해도 원본 `user.name`에는 영향을 주지 않는다.

⇒ ❌ **중첩된 `favorite` 객체는 공유됨**

`favorite`은 **객체(참조형 데이터)** 이므로, **주소값만 복사**됨.

즉, `user.favorite`과 `user2.favorite`은 **동일한 객체를 가리킨다!**

* **따라서, 얕은 복사는 중첩된 객체(객체 안의 객체)를 완전히 복사하지 못하는 한계가 있음**
* 깊은 복사 예시

```jsx
// 중첩된 객체에 대한 깊은 복사

var copyObjectDeep = function (target) {
  var result = {};
  if (typeof target === "object" && target !== null) {
    for (var prop in target) {
      result[prop] = copyObjectDeep(target[prop]); // 재귀적으로 복사
    }
  } else {
    result = target; // 기본형 값은 그대로 복사
  }
  return result;
};

var user = {
  name: "Raccoon",
  favorite: { // 중첩된 객체 (참조형 데이터)
    fruit: "apple",
    drink: "coke",
    hobby: "drive",
  },
};

var user2 = copyObjectDeep(user); // 깊은 복사 실행

// 1. 기본형 데이터 변경 (독립적)
user2.name = "Hello";
console.log(user.name);   // "Raccoon" (원본 유지)
console.log(user2.name);  // "Hello" (사본만 변경됨)
console.log(user.name === user2.name); // false (다른 값)

// 2. 참조형 데이터 변경 (독립적)
user2.favorite.fruit = "banana";
console.log(user.favorite.fruit);  // "apple" (원본 유지)
console.log(user2.favorite.fruit); // "banana" (사본만 변경됨)
console.log(user.favorite.fruit === user2.favorite.fruit); // false (완전히 다른 객체)
```

→ 객체를 복사할 때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할 때, 기본형 데이터일 경우에는 그대로 복사하면 되지만 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야 한다.

→ 참조형 데이터가 있을 때마다 재귀적으로 함수를 호출하여 객체를 완전히 복사해야 한다.

⇒ ✅ **이름(`name`)은 독립적으로 복사됨**

`name`은 **기본형 데이터(string)** 이므로 **값이 복사됨**.

따라서 `user2.name`을 변경해도 `user.name`에는 영향을 주지 않는다!

⇒ ✅ **중첩된 `favorite` 객체도 독립적으로 복사됨**

이전의 얕은 복사에서는 `favorite`이 공유되어 원본까지 변경되었지만,

깊은 복사는 **객체 내부까지 새로 생성**하기 때문에 원본이 영향을 받지 않는다.

* 얕은 복사 vs. 깊은 복사

| 구분            | 얕은 복사          | 깊은 복사             |
| ------------- | -------------- | ----------------- |
| 복사 방식         | 객체의 주소값만 복사    | 객체의 값 자체를 새로 복사   |
| 기본형 데이터       | 독립적            | 독립적               |
| 참조형 데이터       | 공유됨 (원본 변경 가능) | 완전히 독립적 (원본 영향 X) |
| 원본 변경 시 사본 영향 | 영향 있음          | 영향 없음             |

#### 1-6 undefined와 null

자바스크립트에서 값이 없음을 나타내는 값은 2가지 ⇒ undefined, null

*   `undefined`: (1)사용자가 명시적으로 지정하거나, (2)자바스크립트 엔진이 부여하기도 함

    * JS엔진이 undefined를 반환하는 경우
      * **값을 대입하지 않은 변수**, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
      * **객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때**
      * **return 문이 없거나 호출되지 않은 함수의 실행 결과**

    ```jsx
    var arr1 = [undefined, 1];
    var arr2 = [];
    arr2[1] = 1;

    arr1.forEach(function (v, i) {
      console.log(v, i);
    }); 
    // undefined 0
    // 1 1

    arr2.forEach(function (v, i) {
      console.log(v, i);
    }); // 1 1
    // forEach는 배열을 순회하면서 실제 값이 있는 요소만 실행하므로 비어있는 값은 skip

    arr1.map(function (v, i) {
      return v + i;
    }); // [Nan, 2]

    arr2.map(function (v, i) {
      return v + i;
    }); // [empty, 2]

    arr1.filter(function (v, i) {
      return !v;
    }); // [undefined]
    // undefined는 false로 평가되므로 !v === true → 포함됨 ✅

    arr2.filter(function (v, i) {
      return !v;
    }); // []
    // 비어있는 요소는 아예 검사되지 않음 → 실행 대상 X

    arr1.reduce(function (p, c, i) {
      return p + c + i;
    }, ""); // undefined011
    /*
    초기값 ""
    "" + undefined + 0 → "undefined0"
    "undefined0" + 1 + 1 → "undefined011"
    결과: "undefined011"
    */

    arr2.reduce(function (p, c, i) {
      return p + c + i;
    }, ""); // 11
    /*
    0번 인덱스는 비어 있음 → 아예 실행되지 않음!
    "" + 1 + 1 → "11"
    결과: "11"
    */
    ```

    ✅ **배열에 `undefined` 값이 있어도 `forEach`는 실행하지만, 비어있는 인덱스는 실행되지 않음!**

    ✅ **`map`은 원래 배열이 비어있는 경우(`empty slot`) 그대로 유지하면서 반환한다!**

    ✅ **비어있는 요소는 `filter` 대상이 아니므로 무조건 걸러진다!**

    ✅ **`reduce`도 비어있는 요소는 무시하고 동작한다!**
*   정리

    ![image.png](attachment:bcb911d9-fd8f-4d9d-be84-904646a27d01:image.png)
* `null`

```jsx
var n = null;
console.log(typeof n); // object

console.log(n == undefined); // true
console.log(n == null); // true

console.log(n === undefined); // false
console.log(n === null); // true
```

* null은 typeof가 object라는 js 버그가 있기 때문에, 어떤 변수의 값이 null인지 판별하기 위해선 === 일치 연산자를 사용하면 좋다.

#### 1-7 정리

* JS의 데이터 타입에는 크게 기본형과 참조형 존재
* 기본적으로 기본형은 불변값, 참조형은 가변값
* `변수`는 변경가능한 데이터가 담길 수 있는 공간
* `식별자`는 그 변수의 이름
* 변수를 선언하면 컴퓨터는 메모리의 빈 공간에 식별자를 저장, 그 공간의 값은 undefined로 할당. 이후 그 변수에 기본형 데이터를 할당하려고 하면 별도의 공간에 데이터 저장. 참조형은 참조형 데이터 내부 프로퍼티를 위한 변수 영역 별도 확보하고 변수 연결
* 참조형 데이터가 기본형과 메모리 할당과정에서 차이가 있는 이유는 참조형 데이터가 _**여러개의 프로퍼티(변수)를 모은 그룹**_&#xC774;기 때문
* 참조형 데이터를 불변값으로 사용하기 위해서는 깊은 복사를 하거나 라이브러리를 사용
* `없음`을 나타내는 값은 null, undefined 두 가지
* undefined : 어떤 변수에 값이 존재하지 않을 경우
* null : 사용자가 명시적으로 '없음'을 표현하기 위해 대입한 값. 순회 건너뜀
