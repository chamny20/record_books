# 6️⃣ 6장 - 타입 선언과 @types

### ITEM45 devDependencies에 typescript와 @types 추가하기

* npm은 세 가지 종류의 의존성을 구분해서 관리, 각각의 의존성은 모두가 알듯이 package.json 파일 내에 들어있다.
  * **dependencies**
    * 프로젝트를 실행하는 데 필수적인 라이브러리가 포함됨
    * 다른 사용자가 해당 플젝 설치 시, dependencies에 들어 있는 라이브러리도 함께 설치된다. 이를 `transitive(전이) 의존성`이라고 함
  * **devDependencies**
    * 개발하고 테스트하는 데 사용, 런타임에는 필요없는 라이브러리가 포함된다.
    * 다른 사용자가 해당 플젝 설치 시, 여기에 포함된 라이브러리들은 제외된다는 것이 dependencies와 다른 점
  * **peerDependencies**
    * 런타임에 필요하나 의존성을 직접 관리하지 않는 라이브러리들이 포함된다. 플러그인이 그 예시

#### ✅ 요약

* 타입스크립트를 시스템 레벨로 설치하면 안 된다. 타입스크립트를 프로젝트의 devDependencies에 포함시키고 모두 같은 버전을 사용하도록 해야 된다.
* @types 의존성은 dependencies가 아니라 devDependencies에 포함시켜야 한다. 런타임에 @types가 필요한 경우라면 별도의 작업이 필요하다.

### ITEM46 타입 선언과 관련된 세 가지 버전 이해하기

타입스크립트 사용 시 추가로 고려할 사항

* 라이브러리 버전
* 타입 선언 버전
* 타입스크립트 버전

하지만 실제 라이브러리와 타입 정보의 버전이 별도로 관리되는 방식은 문제점이 있다.

1. 라이브러리를 업데이트했지만 실수로 타입 선언은 업데이트하지 않는 경우 - 라이브러리 업데이트와 관련된 새로운 기능 사용 시 타입 오류 발생
2. 라이브러리보다 타입 선언의 버전이 최신인 경우 - 타입 체커는 최신 API를 기준으로 검사하나 실제로 쓰이는 것은 과거 버전이기 때문에 문제가 발생
3. 프로젝트에서 사용하는 타입스크립트 버전보다 라이브러리에서 필요로하는 타입스크립트 버전이 최신인 경우
4. @types 의존성이 중복되는 경우

자체적인 타입 선언은 보통 package.json의 types 필드에서 `.d.ts` 파일을 가리키도록 되어 있다.

* 번들링하여 타입 선언을 하는 경우 부수적인 네 가지 문제점
  * 번들된 타입 선언에 보강 기법으로 해결할 수 없는 오류가 있는 경우
  * 프로젝트 내의 타입 선언이 다른 라이브러리 타입 선언에 의존하는 경우
  * 프로젝트의 과거 버전에 있는 타입 선언에 문제가 있는 경우
  * 타입 선언의 패치 업데이트를 자주 하기 어려운 문제

#### ✅ 요약

* @types 의존성과 관련된 세 가지 버전이 있다. 라이브러리 버전, @types 버전, 타입스크립트 버전이다.
* 라이브러리 업데이트 시, 해당 @types 역시 업데이트 해야 한다.
* 타입 선언을 라이브러리에 포함하는 것과 DefinitelyTyped에 공개하는 것 사이에 장단점을 이해해야 한다. 타입스크립트로 작성되었으면 자체 포함하고, 자바스크립트로 작성된 라이브러리면 타입 선언을 DefinitelyTyped에 공개하는 것이 좋다. (타입스크립트 패키지는 자동으로 @types를 만들어준다.)

### ITEM47 공개 API에 등장하는 모든 타입을 export하기

공개 메서드에 등장한 어떤 형태의 타입이든 export해야 함..

사용자를 위해서.. 사용하는 모든 타입은 다 내보내기\~

#### ✅ 요약

모든 타입은 export하자!

### ITEM48 API 주석에 TSDoc 사용하기

JSDoc 스타일로 주석 만들면.. IDE에서 주석을 툴팁으로 표시

JSDoc

\->@param, @returns

타입스크립트 관점에서는 TSDoc이라고 부른다. 흔히 우리가 아는 JSDoc의 타입스크립트 버전! 주석은 마크다운 형식으로 꾸며진다.

#### ✅ 요약

* 익스포트된 함수, 클래스, 타입에 주석을 달 때는 JSDoc/TSDoc 형태를 사용하자. JSDoc/TSDoc 형태의 주석을 달면 IDE가 주석 정보를 표시해준다.
* @param, @returns 구문과 문서 서식을 위해 마크다운을 사용할 수 있다.
* 주석에 타입 정보를 포함하면 안 된다.

### ITEM49 콜백에서 this에 대한 타입 제공하기

자바스크립트에서 this는 다이나믹 스코프이다. 그렇기 때문에 정의된 방식이 아닌 호출된 방식에 따라 달라진다.

#### ✅ 요약

* `this` 바인딩이 동작하는 원리를 이해해야 한다.
* 콜백 함수에서 `this`를 사용해야 하면, 타입 정보를 명시해야 한다.

### ITEM50 오버로딩 타입보다는 조건부 타입을 사용하기

```tsx
// (1)
function double(x: number | string): number | string
function double(x: any) {
  return x + x
}
const num = double(12) // string | number
const str = double('x') // string | number
// (2)
function double<T extends number | string>(x: T): T
function double(x: any) {
  return x + x
}
const num = double(12) // Type is 12
const str = double('x') // Type is "x"
// (3)
function double(x: number): number
function double(x: string): string
function double(x: any) {
  return x + x
}
const num = double(12) // Type is number
const str = double('x') // Type is string
```

추가적인 오버로딩을 추가할 순 있지만..

가장 좋은 것은 아래처럼 조건부 타입을 사용하는 것!

```tsx
function double<T extends number | string>(
  x: T
): T extends string ? string : number
function double(x: any) {
  return x + x
}
```

* JS의 삼항 연산자처럼 사용 가능
* 오버로딩이 작성하긴 더 쉽더라도, 조건부 타입은 개별 타입의 유니온으로 일반화하기 때문에 타입이 더 정확해진다.

#### ✅ 요약

* 오버로딩 타입보다 조건부 타입을 사용하는 것이 좋다.
* 조건부 타입은 추가적인 오버로딩 없이 유니온 타입을 지원한다.

### ITEM51 의존성 분리를 위해 미러 타입 사용하기

**what is the ‘mirroring’**

`@types/node`와 같은 라이브러리에 의존하는 경우, @types와 무관한 자바스크립트 개발자와 NodeJS와 무관한 타입스크립트 웹 개발자에게는 사용하지 않는 모듈이 포함되어야 하기 때문에 혼란스러울 수 있다.

이러한 상황에서 필요한 메서드와 속성만 별도로 작성해서 사용할 수 있는데, 그것을 미러링(mirroring)이라고 한다.

다시 말하면 필요한 선언부만 라이브러리에서 추출하여 작성 중인 라이브러리에 넣는 것을 말한다.

#### ✅ 요약

* 필수가 아닌 의존성을 분리할 때는 구조적 타이핑을 사용하면 된다.
* 공개한 라이브러리를 사용하는 자바스크립트 사용자가 @types 의존성을 가지지 않게 해야 한다. 그리고 웹 개발자가 NodeJS 관련된 의존성을 가지지 않게 해야 한다.

### ITEM52 테스팅 타입의 함정에 주의하기

타입 선언을 테스트하기는 어렵다. . .

그래도 타입 선언이 예상한 타입으로 결과를 내는지 체크하려면 함수를 호출하는 테스트 파일을 작성하는 방법이 있다. 일반적으로 반환 값에 대한 체크까지는 어려운 경우가 많다. 그래서 반환 타입을 명시적으로 표시하는 경우, 불필요한 타입 선언으로 볼 순 있지만, 테스트 코드 관점에서는 중요한 역할을 하고 있다고 할 수 있다.

* 테스팅을 위해 할당을 사용하는 방법에는 2가지 문제점 존재..
  * 불필요한 변수를 만들어야 함.
    * 이는 헬퍼 함수를 정의하는 방식으로 해결 가능
  * 두 타입이 동일한지 체크하는 것이 아니라 할당 가능성을 체크하고 있다는 문제

#### ✅ 요약

* 타입을 테스트할 때는 특히 함수 타입의 동일성(equality)와 할당 가능성(assignability)의 차이점을 알아야 한다.
* 콜백이 있는 함수를 테스트할 때, 콜백 매개변수의 추론된 타입을 체크해야 한다. 또한 `this`가 API의 일부분이라면 역시 테스트해야 한다.
* 타입 관련된 테스트에서 `any`를 주의해야 한다. 더 엄격한 테스트를 위해 `d.ts.lint` 같은 도구를 사용하는 것이 좋다.
