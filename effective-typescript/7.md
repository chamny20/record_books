# 7️⃣ 7장 - 코드를 작성하고 실행하기

### ITEM53 타입스크립트 기능보다는 ECMAScript 기능을 사용하기

* **열거형(enum)**
  * 숫자 열거형에 0, 1, 2 외에 다른 숫자가 할당되면 위험
  * 상수 열거형에 보통의 열거형과 달리 런타임에 완전히 제거된다.
  * `preserveConstEnums` 플래그를 설정한 상태의 상수 열거형은 보통 열거형처럼 상수 열거형 정보를 유지한다.
  * 문자열 열거형은 런타임의 타입 안정성과 투명성을 제공한다. 하지만 다른 타입과 달리 명목적 타이핑을 사용한다.
* **매개변수 속성**
  * 일반적으로 TS 컴파일은 타입 제거가 되어 코드가 줄어들지만, 매개변수 속성은 코드가 늘어난다.
  * 매개변수 속성이 런타임에 실제로 사용되나, TS 관점에서는 사용되지 않는 것처럼 보인다.
  * 매개변수 속성과 일반 속성을 섞어 사용하면 클래스의 설계가 혼란스러워진다.
*   **네임스페이스와 트리플 슬패시 임포트**

    트리플 슬패시 임포트와 `module` 키워드는 호환성을 위해 남아있는 것이고, ECMAScript 2015의 `import`와 `export`를 사용하면 된다.
* **데코레이터**
  * 앵귤러나 애너테이션이 필요한 프레임워크를 사용하고 있는 게 아니면, 데코레이터가 표준이 되기 전에 타입스크립트에서 데코레이터를 사용하지 않는 게 좋다.

#### ✅ 요약

* 일반적인 TS 코드에서 모든 타입 정보를 제거하면 JS가 되지만 **열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 타입 정보를 제거해도 JS가 되지 않는다.**
* 타입스크립트의 역할을 명확히 하려면 열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터를 사용하지 않는 게 좋다.

### ITEM54 객체를 순회하는 노하우

* 객체 순회 시, 키가 어떤 타입인지 정확히 파악하고 있다면 let k: keyof T와 for-in 루프 사용
  * let k: keyof T와 for-in 루프 사용
    * 정확한 타입 추론
  * 일반적인 방법 Object.entries
    * 키와 값 타입을 다루기 까다로워지긴 하나, 구조적 타이핑 문제는 해결
* 함수의 매개변수로 쓰이는 객체에는 추가적인 키가 존재할 수 있다는 점을 명심하자.

#### ✅ 요약

* 객체를 순회할 때, 키가 어떤 타입인지 정확히 파악하고 있다면 **let k: keyof T 와 for-in 루프**를 사용한다. 함수의 매개변수로 쓰이는 객체에는 추가적인 키가 존재할 수 있다는 점을 명심하자.
* 객체를 순회하며 키와 값을 얻는 가장 일반적인 방법은 **Object.entries**를 사용하는 것이다.

### ITEM55 DOM 계층 구조 이해하기

* DOM 타입 계층 구조 → 각 타입마다 갖고 있는 속성 다름
  * **EventTarget**
    * DOM 타입 중 가장 추상화된 타입
    * 이벤트 리스너 추가 제거, 이벤트 보내기만 가능
  * **Node**
    * Element의 상위 타입
    * text와 주석도 Node
  * **Element**
    * HTMLElement와 SVGElement
  * **HTMLxxxxElement**
    * HTMLInputElement
    * HTMLBodyElement
    * HTMLAnchorElement
* **Event 타입**
  * UIEvent: 모든 종류의 사용자 인터페이스 이벤트
  * MouseEvent: 마우스로부터 발생되는 이벤트
  * TouchEvent: 모바일 기기의 터치 이벤트
  * WheelEvent: 스크롤 휠 돌려서 발생되는 이벤트
  * keyboardEvent: 키 누름 이벤트

#### ✅ 요약

* DOM에는 타입 계층 구조가 있다. DOM타입은 타입 스크립트에서 중요한 정보이며, 브라우저 관련 프로젝트에서 타입 스크립트를 사용할 때 매우 유용하다.
* Node, Element, HTMLElement, EventTarget 간의 차이점, 그리고 Event와 MouseEvent의 차이점을 알아야 한다.
* DOM 엘리먼트와 이벤트에는 충분히 구체적인 타입 정보를 사용하거나, 타입스크립트가 추론할 수 있도록 문맥 정보를 활용해야 한다

### ITEM56 정보를 감추는 목적으로 private 사용하지 않기

타입스크립트는 접근 제어자를 이용해서 멤버 변수의 접근에 제한을 걸 수 있다.

* 접근 제어자 ⇒ 컴파일 시점에만 오류를 표시할 뿐, 런타임에는 아무런 효력이 없다.
  * public
  * protected
  * private
* 정보를 숨기기 위해 사용 가능한 방법 2가지
  * 클로저
    * 클로저의 경우 생성자 외부에서 접근할 수 없으며, 인스턴스를 생성할 때마다 각 메서드의 복사본이 생성되기 때문에(메서드 정의가 생성자 내부에 존재하는 경우) 메모리를 낭비하게 된다.
    * 또한 동일한 클래스의 개별 인스턴스끼리도 서로의 비공개 데이터에 접근하는 것이 불가능하기 때문에 철저하게 비공개이면서 동시에 불편함이 따른다.
  * 접두사로 #을 붙여 비공개 필드 사용
    * 타입 체크와 런타임 모두에서 비공개로 만들 수 있다.
    * 비공개 필드는 클래스 메서드나 동일한 클래스의 개별 인스턴스끼리 접근이 가능하다.
    * 비공개 필드를 지원하지 않는 자바스크립트 버전으로 컴파일하게 되면 WeapMap을 사용한 구현으로 대체된다.

#### ✅ 요약

* public, protected, private 접근 제어자는 타입 시스템에서만 강제될 뿐이다. 런타임에서는 소용이 없으며 단언문을 통해 우회할 수 있다. 접근 제어자로 데이터를 감추려고 해서는 안 된다.
* 확실히 데이터를 감추고 싶다면 클로저를 사용해야 한다.

### ITEM57 소스맵을 사용하여 타입스크립트 디버깅하기

* 타입스크립트 코드를 실행한다는 것
  * 타입스크립트 컴파일러가 생성한 자바스크립트 코드를 실행한다는 것

디버거 → 런타임에 동작

따라서, 현재 동작하는 코드가 어떤 과정을 거쳐서 만들어진 것인지 알지 못한다.

* 디버깅을 하면 보게 되는 코드는?
  * 전처리기, 컴파일러, 압축기를 거친 JS 코드

..이러한 디버깅 문제를 해결하기 위해 나온 솔루션: source map(소스맵)

* 소스맵
  * TS와 함께 번들러나 압축기를 사용하고 있다면, 번들러나 압축기가 각자의 소스맵을 생성하게 된다. 이상적인 디버깅 환경이 되려면 생성된 JS가 아닌 원본 TS 소스로 매핑되도록 해야 한다.
  * 상용 환경에 소스맵이 유출되고 있는지 확인해야 한다.

\*타입 체커가 코드를 실행하기 전에 많은 오류를 잡을 수 있지만, 디버거를 대체할 수는 없다.

#### ✅ 요약

* 원본 코드가 아닌 변환된 자바스크립트 코드를 디버깅하지 말자. 소스맵을 사용해서 런타임에 타입스크립트 코드를 디버깅하자.
* 소스맵이 최종적으로 변환된 코드에 완전히 매핑되었는지 확인해야 한다.
* 소스맵에 원본 코드가 그대로 포함되도록 설정되어 있을 수도 있다. 공개되지 않도록 설정을 확인하자.
