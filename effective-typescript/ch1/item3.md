# ITEM3

### ITEM3 코드 생성과 타입이 관계없음을 이해하기

타입스크립트 컴파일러는 두 가지 역할을 수행한다.

* 최신 ts/js를 브라우저에서 동작할 수 있도록 구버전의 js로 트랜스파일(translate+compile)한다.
* 코드의 타입 오류를 체크한다.

**`💡타입 오류가 있는 코드도 컴파일이 가능하다.`**

컴파일은 타입 체크와 독립적으로 동작하기 때문에, 타입 오류가 있는 코드도 컴파일이 가능하다.

\<aside> ❓ **컴파일과 타입 체크**

컴파일: 오직 코드 생성만이 컴파일이라고 할 수 있다. 작성한 ts가 유효한 js라면 ts 컴파일러는 컴파일을 수행한다. 그러므로 코드에 오류가 있을 때 \*\*‘타입 체크에 문제가 있다’\*\*라고 말하는 것이 더 정확한 표현이다.

\</aside>

\*만약 오류가 있을 때 컴파일하지 않으려면, tsconfig.json에 noEmitOnError를 설정하거나 빌드 도구에 동일하게 적용하면 된다.

**`💡런타임에는 타입 체크가 불가능하다.`**

* ts의 타입은 ‘제거 가능’(erasable)하다.
* 실제로 js로 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 그냥 제거되어 버린다.
* 타입 정보를 유지하는 또다른 방법으로 런타임에 접근 가능한 타입 정보를 명시적으로 저장하는 ‘태그’ 기법 존재
* 타입(런타임 접근 불가)과 값(런타임 접근 가능)을 둘 다 사용하는 기법도 있음 ⇒ 타입을 클래스로 만들기

**`💡타입 연산은 런타임에 영향을 주지 않는다.`**

```jsx
function asNumber(val: number | string):number {
	return val as number;
}
```

js로 변환하면?

```jsx
function asNumber(val) {
	return val;
}
```

⇒ 코드에 아무런 정제 과정이 없다!

⇒ `as number`는 타입 연산이고 런타임 동작에는 아무런 영향을 미치지 않는다.

⇒ 값을 정제하기 위해서는 런타임의 타입을 체크해야 하고 js 연산을 통해 변환을 수행해야 한다.

```jsx
function asNumber(val: number | string):number {
	return typeof(val) === 'string' ? Number(val) : val;
}
```

**`💡런타임 타입은 선언된 타입과 다를 수 있다.`**

* ts에서는 런타임 타입과 선언된 타입이 맞지 않을 수 있다.
* 선언된 타입이 언제든지 달라질 수 있다는 것을 명심해야 한다.

**`💡타입스크립트 타입으로는 함수를 오버로드할 수 없다.`**

타입스크립트가 함수 오버로딩 기능을 지원하긴 하지만, 온전히 타입 수준에서만 동작한다.

```jsx
function add(a: number, b: number) { return a + b;}
// ~~~ 중복된 함수 구현입니다.
function add(a: string, b: string) { return a + b;}
// ~~~ 중복된 함수 구현입니다.
```

**`💡타입스크립트 타입은 런타임 성능에 영향을 주지 않는다.`**

* 타입과 타입 연산자는 js 변환 시점에 제거된다.
* ‘런타임’ 오버헤드가 없는 대신, 타입스크립트 컴파일러는 ‘빌드타임’ 오버헤드가 있다.
* 호환성과 성능 사이의 선택은 컴파일 타깃과 언어 레벨의 문제이며 여전히 타입과는 무관하다.

#### ✅요약

* 코드 생성은 타입 시스템과 무관하다. ts 타입은 런타임 동작이나 성능에 영향을 주지 않는다.
* 타입 오류가 존재하더라도 코드 생성(컴파일)은 가능하다.
* ts 타입은 런타임에 사용할 수 없다.
