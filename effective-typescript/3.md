# 3️⃣ 3장 - 타입 추론

### ITEM19 추론 가능한 타입을 사용해 장황한 코드 방지하기

타입 추론이 된다면 명시적 타입 구문은 불필요하다. 코드의 모든 변수에 타입을 선언하는 것은 비생산적이며 형편없는 스타일!

* 타입 구문이 필요한 경우
  * 함수 / 메서드 시그니처
* 타입 구문이 필요하지 않은 경우
  * 함수 내의 지역 변수
  * 매개변수 기본값이 있는 경우
  * 타입 정보가 있는 라이브러리의 콜백함수 매개변수 타입
* 타입이 추론되지만 타입을 명시하고 싶은 경우
  * 객체 리터럴을 정의할 때
  * 함수의 반환에 타입을 명시

### ITEM20 다른 타입에는 별도의 변수 사용하기

변수의 값은 바뀔 수 있지만 그 타입은 바뀌지 않아야 한다. 별도의 변수 도입하는 게 베스트.

왜?

* 서로 관련이 없는 두 개의 값을 분리한다.
* 변수명을 더 구체적으로 지을 수 있다.
* 타입 추론을 향상시키며, 타입 구문이 불필요해진다.
* 타입이 더 간결해진다.
* let 대신 const로 변수를 선언하게 된다.

### ITEM21 타입 넓히기

타입 넓히기 ⇒ 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추하기 위한 방법

* 타입 넓히기 때문에 발생하는 오류

```tsx
interface Vector3 { x:number; y:number; z:number; }
function getComponent(vector: Vector3, axis: 'x'|'y'|'z') {
 return vector[axis];
}

let x = 'x'; // string
let vec = {x: 10, y: 20, z:30};
getComponent(vec, x); // string 형식의 인수는 'x'|'y'|'z' 형식의 배개변수에 할당될 수 없습니다.
```

* 타입 추론 강도를 제어하는 방법
  * const 키워드
  * 명시적 타입 구문을 제공
  * 타입 체커에 추가적인 문맥을 제공
  * const 단언문 사용

### ITEM22 타입 좁히기

* null 체크
* 예외 throw
* instanceof 사용하기
* key in object 속성 체크
* Array.isArray 내장 함수
* 태그된 유니온, 구별된 유니온
* 사용자 정의 타입 가드

### ITEM23 한꺼번에 객체 생성하기

변수의 값은 변경될 수 있지만, 타입스크립트의 타입은 일반적으로 변경되지 않는다. 객체를 생성할 때는 속성을 하나씩 추가하기보다는, 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다. (오류 발생에 대비)

* 타입 단언문을 사용해 객체를 나눠서 만들기
* 스프레드 연산자 활용하기
* 타입에 조건부 속성을 추가하기
* 객체, 배열을 변환해서 새로운 객체나 배열을 생성하기

***

### ITEM24 일관성 있는 별칭 사용하기

중복되는 코드를 줄이기 위해 임시 변수를 뽑아낸 경우

→ undefined 오류가 발생

→ 이유: polygon.bbox를 별도의 box라는 별칭을 만들었고, 첫 번째 예제에서는 잘 동작했던 제어 흐름 분석을 방해했기 때문

이러한 경우는 “별칭은 일관성 있게 사용한다”라는 기본 원칙을 지키면 방지할 수 있다.

⇒ 객체 비구조화를 이용하면 보다 간결한 문법으로 일관된 이름을 사용할 수 있다.

* **객체 비구조화**
  * 전체 bbox 속성이 아니라 x와 y가 선택적 속성일 경우에 속성 체크가 더 필요하다. 따라서 타입의 경계에 null 값을 추가하는 것이 좋다.
  * bbox에는 선택적 속성이 적합했지만 holes는 그렇지 않다. 빈 배열은 ‘holes 없음’을 나타내는 좋은 방법
* 별칭은 타입 체커뿐만 아니라 런타임에도 혼동을 야기할 수 있다.

#### ✅ 요약

* 별칭은 타입스크립트가 타입을 좁히는 것을 방해한다. 따라서 변수에 별칭을 사용할 때는 일관되게 사용해야 한다.
* 비구조화 문법을 사용해서 일관된 이름을 사용하는 것이 좋다.
* 함수 호출이 객체 속성의 타입 정제를 무효화할 수 있다는 점을 주의해야 한다. 속성보다 지역 변수를 사용하면 타입 정제를 믿을 수 있다.

### ITEM25 비동기 코드에는 콜백 대신 async함수 사용하기

악명 높은 콜백 지옥 (callback hell)

..

ES2015는 이러한 콜백 지옥을 극복하기 위해 promise 개념 도입

ES2017에서는 async와 await 키워드를 도입하여 콜백 지옥을 더욱 간단하게 처리 가능

* async & await
  * await: 각각의 프로미스가 처리될 때까지 fetchPages 함수의 실행을 멈춘다.
  * async 함수 내에서 await 중인 프로미스가 거절되면 예외를 던진다.
  * 일반적인 try/catch 구문을 사용할 수 있다.
  * 런타임에 관계없이 타입스크립트에서는 async/await를 사용할 수 있다.
  * 코드 작성도 쉬움
  * 타입 추론도 쉬움
  * ex. 병렬로 페이지를 로드하고 싶다면 Promise.all을 사용해 프로미스를 조합하면 된다.
* **Promise.race**
  * 프로미스에 타임아웃을 추가하는 방법 흔히 사용됨
  * Promise.race의 반환 타입은 입력 타입들의 유니온
  * 프로미스를 사용하면 타입스크립트의 모든 타입 추론이 제대로 동작하게 된다.

#### ✅ 요약

* 콜백보다는 프로미스를 사용하는 게 코드 작성과 타입 추론 면에서 유리하다.
* 가능하면 프로미스를 생성하기보다는 async와 await를 사용하는 것이 좋다. 간결하고 직관적인 코드를 작성할 수 있고 모든 종류의 오류를 제거할 수 있다.
* 어떤 함수가 프로미스를 반환한다면 async로 선언하는 것이 좋다.

### ITEM26 타입 추론에 문맥이 어떻게 사용되는지 이해하기

TS는 타입을 추론할 때 단순히 값만 고려하지 않고, 값이 존재하는 곳의 문맥까지 살핀다.

**`‘string’ 형식의 인수는 ‘Language’ 형식의 매개변수에 할당될 수 없습니다.`**

에러 해결 방법은?

→ 타입 선언에서 language의 가능한 값을 제한하는 것

→ language를 상수로 만드는 것 (let이 아닌 const 사용)

* 튜플 사용시 주의점
  * const로 정의한 경우 number\[]로 추론, 즉 길이를 알 수 없는 숫자의 배열
  * 많은 배열이 이와 맞지 않는 수의 요소를 가지므로 튜플 타입에 할당할 수 없다.
  * 오류를 고치려면?
    * ‘상수 문맥’을 제공하는 것
    * const loc = \[10, 20] as const;와 같이! ⇒ 하지만 ‘너무 과하게’ 정확함
    * 최선의 해결책: panTo 함수에 readonly 구문을 추가하는 것

#### ✅ 요약

* 타입 추론에서 문맥이 어떻게 쓰이는지 주의해서 살펴봐야 한다.
* 변수를 뽑아서 별도로 선언했을 때 오류가 발생한다면 타입 선언을 추가해야 한다.
* 변수가 정말로 상수라면 상수 단언(as const)을 사용해야 한다. 그러나 상수 단언을 사용하면 정의한 곳이 아니라 사용한 곳에서 오류가 발생하므로 주의해야 한다.

### ITEM27 함수형 기법과 라이브러리로 타입 흐름을 유지하기

* jQuery
* Underscore
* Lodash
* Ramda

JS와 달리 TS로 작성하면 서드파티 라이브러리를 사용하는 것이 무조건 유리하다.

#### ✅ 요약

* 타입 흐름을 개선하고, 가독성을 높이고, 명시적인 타입 구문의 필요성을 줄이기 위해 직접 구현하기보다는 내장된 함수형 기법과 로대시 같은 유틸리티 라이브러리를 사용하는 것이 좋다.
