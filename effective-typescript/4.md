# 4️⃣ 4장 타입 설계

### ITEM28 유효한 상태만 표현하는 타입을 지향하기

타입을 설계할 때는 어떤 값들을 포함하고 어떤 값들을 제외할지 신중하게 생각해야 한다. 유효한 상태를 표현하는 값만 허용한다면 코드를 작성하기 쉬워지고 타입 체크가 용이해진다.

#### ✅ 요약

* 유효한 상태와 무효한 상태를 둘 다 표현하는 타입은 혼란을 초래하기 쉽고 오류를 유발하게 된다.
* 유효한 상태만 표현하는 타입을 지향해야 한다. 코드가 길어지거나 표현하기 어렵지만 결국은 시간을 절약하고 고통을 줄일 수 있다.

### ITEM29 사용할 때는 너그럽게, 생성할 때는 엄격하게

29 제목은.. 존 포스텔이 쓴 견고성 원칙 또는 포스텔의 법칙에서 따온 것

> TCP 구현체는 견고성의 일반적 원칙을 따라야 한다. 당신의 작업은 엄격하게 하고, 다른 사람의 작업은 너그럽게 받아들여야 한다.

#### ✅ 요약

* 보통 매개변수 타입은 반환 타입에 비해 범위가 넓은 경향이 있다. 선택적 속성과 유니온 타입은 반환 타입보다 매개변수 타입에 더 일반적이다.
* 매개변수와 반환 타입의 재사용을 위해서 기본 형태(반환)와 느슨한(매개변수) 형태를 도입하는 것이 좋다.

### ITEM30 문서에 타입 정보를 쓰지 않기

함수의 입출력의 타입을 코드로 표현하는 것이 주석보다 더 나은 방법이다.

만약 특정 매개변수를 설명하고 싶다면 JSDoc의 `@param` 구문을 사용하면 된다.

#### ✅ 요약

* 주석과 변수명에 타입 정보를 적는 것은 피해야 한다. 타입 선언이 중복되는 것으로 끝나면 다행이지만 최악의 경우는 타입 정보에 모순이 발생하게 된다.
* 타입이 명확하지 않은 경우는 변수명에 단위 정보를 포함하는 것을 고려하는 것이 좋다.

### ITEM31 타입 주변에 null 값 배치하기

값이 전부 null이거나 전부 null이 아닌 경우로 분명히 구분된다면, 값이 섞여 있을 때 보다 다루기 쉽다.

• 최소값이나 최대값이 0인 경우, 값이 덧씌워져 버린다. 예를들어 `extent([0, 1, 2])`의 결과는 `[0,1]` 가 아니라 `[1,2]` 이다. • `nums` 배열이 비어있다면 함수는 `[undefined, undefined]` 를 반환한다. `undefined` 를 포함하는 객체는 다루기 어렵고 권장되지 않는다.

#### ✅ 요약

* 한 값의 null 여부가 다른 값의 null 여부에 암시적으로 관련되도록 설계하면 안된다.
* API 작성 시에는 반환 타입을 큰 객체로 만들고, 반환 타입 전체가 null이거나 null이 아니게 만들어야한다.
* 클래스를 만들 때는 필요한 모든 값이 준비되었을 때 생성하여 null이 존재하지 않도록 하는 것이 좋다.
* `strictNullChecks` 를 설정하면 코드에 많은 오류가 표시되지만, null과 관련된 문제점을 찾아낼 수 있기 때문에 반드시 필요하다.

### ITEM32 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기

각각 타입의 계층을 분리된 인터페이스로 둔 다음 → Layer를 정의할 때 각각 정의했던 인터페이스를 유니온으로 합쳐서 정의하면 잘못된 조합으로 섞이는 경우를 방지할 수 있다.

⇒ TS가 코드의 정확성을 체크하는 데 도움이 된다.

#### ✅ 요약

* 유니온 타입의 속성을 여러 개 가지는 인터페이스에서는 속성 간의 관계가 분명하지 않기 때문에 실수가 자주 발생하므로 주의해야 한다.
* 유니온 인터페이스보다 인터페이스의 유니온이 더 정확하다.
* 타입스크립트가 제어 흐름을 분석할 수 있도록 타입에 태그를 넣는 것이 좋다. 태그된 유니온은 타입스크립트와 매우 잘 맞는 패턴이기 때문이다.

### ITEM33 string 타입보다 더 구체적인 타입 사용하기

string 타입의 범위는 매우 넓다. string 타입으로 변수를 선언하려 할때, 혹시 **그보다 더 좁은 타입이 적절하지 않을지 검토**해야한다.

→ string 타입이 남용된 코드를 \*\*"문자열을 남발하여 선언되었다(stringly typed)"\*\*고 표현한다.

* **string 보다 더 좁은 타입을 사용하는 것에 대한 이점**
  * 타입을 명시적으로 정의함으로써 다른 곳으로 값이 전달되어도 타입 정보가 유지된다.
  * 타입을 명시적으로 정의하고 해당 타입의 의미를 설명하는 주석을 붙여 넣을 수 있다.
  * keyof 연산자로 더욱 세밀하게 객체의 속성 체크가 가능해진다.

#### ✅ 요약

* 문자열을 남발하여 선언된 코드를 피하자. 조금 더 구체적인 타입을 사용해야 한다.
* 변수의 범위를 보다 정확하게 표현하고 싶다면 string 타입보다는 문자열 리터럴 타입의 유니온을 사용하자.
* 객체의 속성 이름을 함수 매개변수로 받을 때는 string 보단 `keyof T` 를 사용하자.

### ITEM34 부정확한 타입보다는 미완성 타입을 사용하기

타입 선언의 정밀도를 높이는 일에는 주의해야한다. 실수가 발생하기 쉽고 잘못된 타입은 차라리 타입이 없는 것보다 못할 수 있기 때문이다.

#### ✅ 요약

* 타입이 없는 것보단 잘못된 것이 더 나쁘다.
* 정확하게 타입을 모델링할 수 없다면, 부정확하게 모델링하지 말아야 한다. 또한 `any`와 `unknown`을 구별해서 사용해야 한다.
* 타입 정보를 구체적으로 만들수록 오류 메시지와 자동 완성 기능에 주의를 기울여야 한다.

### ITEM35 데이터가 아닌, API와 명세를 보고 타입 만들기

파일 형식, api, 명세 등 우리가 다루는 타입 중 몇 개는 프로젝트 외부에서 비롯된 것이다. 이런 경우엔 타입을 직접 생성하지 않고 자동으로 생성할 수 있다.

#### ✅ 요약

* 코드의 안전성을 얻기 위해서는 api 또는 데이터 형식에 대한 타입 생성을 고려해야 한다.
* 데이터에 드러나지 않는 예외적인 경우가 문제가 될 수 있기 때문에 데이터보단 명세로부터 코드를 생성하는 것이 좋다.
