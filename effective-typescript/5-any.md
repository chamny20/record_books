# 5️⃣ 5장 - any 다루기

타입스크립트의 타입 시스템

→ 선택적, 점진적

### ITEM38 any 타입은 가능한 한 좁은 범위에서만 사용하기

예제를 확인해보자.

* f1과 f2
  * f1에 사용된 `x: any`보다 f2에 사용된 x as any 형태가 권장됨
  * any 타입이 함수의 매개변수에서만 사용된 표현식이므로 다른 코드에는 영향을 미치지 않기 때문
  * f1에서는 함수의 마지막까지 x의 타입이 any인 반면, f2에서는 processBar 호출 이후에 x가 그대로 Foo 타입임
* 객체 전체를 any로 단언하면 다른 속성들 역시 타입 체크가 되지 않는 부작용이 생긴다.

#### ✅ 요약

* 의도치 않은 타입 안정성의 손실을 피하기 위해서 any의 사용 범위를 최소한을 좁혀야 한다.
* 함수의 반환 타입이 any인 경우 타입 안정성이 나빠진다. 따라서 any 타입을 반환하면 절대 안된다.
* 강제로 타입 오류를 제거하려면 any 대신 @ts-ignore 사용하는 것이 좋다.

### ITEM39 any를 구체적으로 변형해서 사용하기

any… 매우 위험한 아이!

모든 숫자, 문자열, 배열, 객체, 정규식, 함수, 클래스, DOM 엘리먼트는 물론 null과 undefined까지도 포함된다.

⇒ 구체적인 타입을 찾아 타입 안정성을 높이도록 해야 함!

예제)

any를 사용하는 getLengthBad보다는 any\[]를 사용하는 getLength가 더 좋은 함수

* 함수 내의 array.length 타입이 체크된다.
* 함수의 반환 타입이 any 대신 number로 추론된다.
* 함수 호출될 때 매개변수가 배열인지 체크된다.
* 함수 타입에서도 단순히 any를 사용해서는 안됨 → 최소한으로 구체화 가능한 방법은?
  * 매개변수 없이 호출 가능한 모든 함수
    * type Fn0 = () ⇒ any;
  * 매개변수 1개
    * type Fn1 = (arg: any) ⇒ any;
  * 모든 개수의 매개변수
    * type FnN = (…args: any\[]) ⇒ any;
    * any로 선언해도 동작하지만 any\[]로 선언하면 배열 형태라는 것을 알 수 있어 더 구체적

⇒ 이 3가지 방법이 그냥 any보다는 구체적

#### ✅ 요약

* any를 사용할 때는 정말로 모든 값이 허용되어야만 하는지 면밀히 검토해야 한다.
* any보다 더 정확하게 모델링할 수 있도록 any\[] 또는 {\[id: string]: any} 또는 () ⇒ any처럼 구체적인 형태를 사용해야 한다.

### ITEM40 함수 안으로 타입 단언문 감추기

프로젝트 전반에 위험한 타입 단언문이 드러나 있는 것보다, 제대로 타입이 정의된 함수 안으로 타입 단언문을 감추는 것이 더 좋은 설계이다.

예제) 함수 캐싱

* 함수 캐싱은 리액트 같은 프레임워크에서 실행 시간이 오래 걸리는 함수 호출을 개선하는 일반적인 기법

#### ✅ 요약

* 타입 선언문은 일반적으로 타입을 위험하게 만들지만 상황에 따라 필요하기도 하고 현실적인 해결책이 되기도 한다. 불가피하게 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨기도록 한다.

### ITEM41 any의 진화를 이해하기

* any 타입의 진화는 noImplictAny가 설정된 상태에서 변수의 타입이 암시적인 any인 경우에만 일어난다.
* any 타입의 진화는 any 타입에 어떤 값을 할당할 때만 발생한다. 그리고 어떤 변수가 암시적 any 상태일 때 값을 읽으려고 하면 오류가 발생한다.
* any가 진화하는 방식은 일반적인 변수가 추론되는 원리와 동일

#### ✅ 요약

* 일반적인 타입들은 정제되기만 하는 반면, 암시적 any와 any\[] 타입은 진화할 수 있다. 이러한 동작이 발생하는 코드를 인지하고 이해할 수 있어야 한다.
* any를 진화시키는 방식보다 명시적 타입 구문을 사용하는 것이 안전한 타입을 유지하는 방법이다.



### ITEM42 모르는 타입의 값에는 any 대신 unknown 사용하기

* **`unknown`**
  * 어떤 타입이든 할당이 가능하다.
  * 어떤 타입으로도 할당이 불가능하다.
* **`any`** vs **`unknown`**
  * any
    * 어떤 타입으로도 받을 수 있고, 어떤 타입으로도 사용 가능
    * 타입 체커가 any는 검사하진 않음
  * unknown
    * 하지만 unknown을 사용하기 위해선 타입을 변환시켜줘야 함
    * 비교적 안전
    * 강제로 타입 변환을 하지 않아도 타입 체커에게 unknown이 무엇인지 알려주는 방법도 존재
*   **{ } vs object vs unknown**

    * unknown: 모든 값을 가질 수 있다.
    * { }: null과 undefined를 제외한 모든 값을 가질 수 있다.
    * object: 원시 타입을 제외한 모든 타입을 가질 수 있다.

    ⇒ 가질 수 있는 범위: unknown > object > {}

#### ✅ 요약

* 어떤 값이 존재하지만 타입을 확신할 순 없을 때 unknown 사용
* unknown은 모든 타입의 상위 타입이고, never는 모든 타입의 하위 타입이다.
* {} 타입은 null과 undefined를 제외한 모든 값을 포함한다.

### ITEM43 몽키 패치보다는 안전한 타입 사용하기

* **몽키 패치**
  * 원래 소스코드를 변경하지 않고 실행 시 코드 기본 동작을 추가, 변경 또는 억제하는 기술
  * 쉽게 말해 어떤 기능을 위해 이미 있던 코드에 삽입하는 것
  * 런타임에 코드의 동작을 동적으로 업데이트하는 데 사용되는 기술
* **해결 방법**
  * interface 보강 기법
    * 타입이 더 안전
    * 주석 추가
    * 자동완성 사용
  * 구체적인 타입 단언문 만들어 사용해서 확장 가능

#### ✅ 요약

* 전역 변수나 DOM에 데이터를 저장하지 말고 데이터를 분리하여 사용해야 한다.
* 내장 타입에 데이터를 저장해야 하는 경우, 안전한 타입 접근법 중 하나를 사용해야 한다.
* 보강의 모듈 영역 문제를 이해해야 한다.

### ITEM44 타입 커버리지를 추적하여 타입 안정성 유지하기

noImplicitAny를 설정해도 여전히 모든 any 타입과 관련된 문제로 안전하다고 할 순 없다.

* **명시적 any 타입**
  * any 타입의 범위를 좁히고 구체적으로 만들어도 여전히 any 타입
* **서드파티 타입 선언**
  * @types 선언 파일로부터 any 타입이 전파되기 때문에 특별히 더 조심해야 한다.
* npm의 type-coverage 패키지를 통해 any 추적 가능

#### ✅ 요약

* \*\*`noImplicitAny`\*\*가 설정되어 있어도, 명시적 any 또는 서드파티 타입 선언 @types를 통해 any 타입은 코드 내에 여전히 존재할 수 있다.
* 작성한 프로그램의 타입이 얼마나 잘 선언되는지 추적해야 한다. 추적을 통해 any의 사용을 줄여 나갈 수 있고 타입 안정성을 꾸준히 높일 수 있다.
